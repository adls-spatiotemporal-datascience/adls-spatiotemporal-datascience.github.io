[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spatiotemporal Datascience",
    "section": "",
    "text": "Welcome to the course Spatiotemporal Datascience\n\n\n\nImage Source\n\n\nThis course is taught in the Bachelor Degree Applied Digital Life Sciences at the Zurich University of Applied Sciences (ZHAW).\nIn this course, we will learn about methods and tools to analyze spatiotemporal data. We expect that you already have had some experience with spatial data and programming. To start the course, we will recap the following topic from the course GISc and Geodatabases: Geocomputation with R with raster and vector data\n\nOur preliminary schedule is as follows. Please note that this schedule is subject to change!\n\n\n\n\n\n\n\n\n#\nCW\nDate\nLesson\nLecturer\n\n\n\n\n1\n8\n18.02.25\nModule introduction / Vector Data (recap)\nrata\n\n\n2\n9\n25.02.25\nGeoPython Confence\nrata\n\n\n3\n10\n04.03.25\nRaster Data (recap)\nrata\n\n\n4\n11\n11.03.25\nVector Advanced\nrata\n\n\n5\n12\n18.03.25\nRaster Advanced\nrata\n\n\n6\n13\n25.03.25\ntba\ntba\n\n\n7\n14\n01.04.25\nInterpolation\nlaup\n\n\n8\n15\n08.04.25\ntba\ntba\n\n\n9\n16\n15.04.25\nNetwork Analysis I: Centrality\nlaup\n\n\n10\n17\n22.04.25\nNetwork Analysis II: Shortest Path / TSP\nlaup\n\n\n11\n18\n29.04.25\nProject Week (no class)\nrata\n\n\n12\n19\n06.05.25\nMovement Analysis I: Patterns\nlaup\n\n\n13\n20\n13.05.25\nMovement Analysis II: Context\nlaup\n\n\n14\n21\n20.05.25\ntba\ntba\n\n\n15\n22\n27.05.25\ntba\ntba",
    "crumbs": [
      "Welcome to the course *Spatiotemporal Datascience*"
    ]
  },
  {
    "objectID": "week-1-simple-features.html",
    "href": "week-1-simple-features.html",
    "title": "Simple Features",
    "section": "",
    "text": "Simple feature standard",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "week-1-simple-features.html#simple-feature-standard",
    "href": "week-1-simple-features.html#simple-feature-standard",
    "title": "Simple Features",
    "section": "",
    "text": "Simple features is an open standard (ISO 19125-1:2004) developed and endorsed by the Open Geospatial Consortium (OGC)\nThe standard is widely implemented in spatial databases (such as PostGIS), desktop GIS (such as ArcGIS, QGIS) and scripting languages (such as R, Python)\n\n\nThis is the secret message for Area 2",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "week-1-simple-features.html#what-is-a-feature",
    "href": "week-1-simple-features.html#what-is-a-feature",
    "title": "Simple Features",
    "section": "What is a feature?",
    "text": "What is a feature?\nThe standard says:\n\nA simple feature is defined [‚Ä¶] to have both spatial and non-spatial attributes. Spatial attributes are geometry valued, and simple features are based on 2D geometry with linear interpolation between vertices.\n\n\nA feature is thought of as a thing / an object in the real world, such as a building or a tree.\nFeatures have:\n\na geometry describing where on Earth the feature is located\nattributes, which describe other properties.\n\nFor example:\n\nThe geometry of a tree can be the delineation of its crown, of its stem, or the point indicating its center\nattributes (properties) may include its height, color, diameter at breast height at a particular date, and so on",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "week-1-simple-features.html#simple-feature-model",
    "href": "week-1-simple-features.html#simple-feature-model",
    "title": "Simple Features",
    "section": "Simple Feature Model",
    "text": "Simple Feature Model\n\nSimple features is a hierarchical data model that represents a wide range of geometry types.\nAll geometries are composed of points in a 2-, 3- or 4-dimensional space\nOf 18 geometry types supported by the specification, only the following seven (see Figure¬†1.1 and Table¬†1.1) are used in the vast majority of geographic research:\n\nThree basic types: points, linestrings, polygons\nThree composite types: mutlipoints, multilinestrings, multipolygons\nOne special case: geometrycollection (which can be a conglomarate of all the afore mentioned)\n\nThese seven core geometry types are fully supported by the R package sf (Pebesma 2018)\n\n\n\n\n\n\n\nFigure¬†1.1: Image source: Dorman (2023)\n\n\n\n\n\n\n\nTable¬†1.1: Source: Pebesma (2018)\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n# of Dimension\n\n\n\n\nPOINT\nzero-dimensional geometry containing a single point\n0\n\n\nLINESTRING\nsequence of points connected by straight1 line pieces\n1\n\n\nPOLYGON\nsequence of points form a closed2 ring3\n2\n\n\nMULTIPOINT\nset of points\n0\n\n\nMULTILINESTRING\nset of linestrings\n1\n\n\nMULTIPOLYGON\nset of polygons\n2\n\n\nGEOMETRYCOLLECTION\nset of geometries of any of the above types\nNA",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "week-1-simple-features.html#simple-features-in-r",
    "href": "week-1-simple-features.html#simple-features-in-r",
    "title": "Simple Features",
    "section": "Simple features in R",
    "text": "Simple features in R\nSimple Features in R is modelled in three levels:\n\nSimple feature geometries (sfg): Individual Simple Feature objects\nSimple Feature geometry columns (sfc): A list column of sfgs\nSimple Features (with attributes): A sfc with attributes, i.e.¬†additional columns",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "week-1-simple-features.html#sfg-simple-feature-geometry",
    "href": "week-1-simple-features.html#sfg-simple-feature-geometry",
    "title": "Simple Features",
    "section": "sfg: simple feature geometry",
    "text": "sfg: simple feature geometry\nSimple feature geometries are implemented as R native data, using the following rules:\n\na single POINT is a numeric vector\na set of points, e.g.¬†in a LINESTRING or ring of a POLYGON is a matrix, each row containing a point\nany other set is a list\n\nLet‚Äôs create some simple feature geometries by hand: However, creator functions are rarely used in practice, since we typically bulk read and write spatial data. They are useful for illustration purposes.\n\nPoints\n\nlibrary(sf)\nfracht &lt;- st_point(c(2685374, 1256519))\n\nfracht\n\n\nplot(fracht)\n\n\n\n\n\n\n\n\n\n\nLinestrings\n\ncoords &lt;- c(\n  2684336, 1255553, \n  2682705, 1258929\n  ) |&gt; \n  matrix(ncol = 2, byrow = TRUE)\n\ncoords\n\n        [,1]    [,2]\n[1,] 2684336 1255553\n[2,] 2682705 1258929\n\n\n\npiste &lt;- st_linestring(coords)\n\npiste\n\n\nplot(piste)\n\n\n\n\n\n\n\n\n\n\nPolygons\n\ncoords_2 &lt;- c(\n  2684142, 1255702, # ‚Ü∞ \n  2685600, 1256958, # start and end must\n  2682534, 1259699, # be identical (closed)\n  2684142, 1255702  # ‚Ü≤ \n) |&gt; \n  matrix(ncol = 2, byrow = TRUE) |&gt; \n  list()\n\ncoords_2\n\n[[1]]\n        [,1]    [,2]\n[1,] 2684142 1255702\n[2,] 2685600 1256958\n[3,] 2682534 1259699\n[4,] 2684142 1255702\n\n\n\nflughafen &lt;- st_polygon(coords_2)\n\nflughafen\n\n\nBefore we said that the ring of a polygon is a matrix. Now we are turning it into a list. This is because a polygon could contain holes, which are additional rings.\n\n\nplot(flughafen)",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "week-1-simple-features.html#sfc-simple-feature-geometry-columns",
    "href": "week-1-simple-features.html#sfc-simple-feature-geometry-columns",
    "title": "Simple Features",
    "section": "sfc: Simple feature geometry columns",
    "text": "sfc: Simple feature geometry columns\n\nAs you might have noticed, we didn‚Äôt specify a CRS when creating the sfg objects. This is because we weren‚Äôt able to.\nIf we convert the sfg to sfc, we can (and should) specify a crs.\n(Usually, a sfc contains more than one sfg. This is not mandatory, and for convenience we will just use a single sfg to showcase sfc)\n\n\nfracht_sfc &lt;- st_sfc(fracht, crs = 2056)\n\nfracht_sfc\n\nGeometry set for 1 feature \nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 2685374 ymin: 1256519 xmax: 2685374 ymax: 1256519\nProjected CRS: CH1903+ / LV95\n\n\n\n\npiste_sfc &lt;- st_sfc(piste, crs = 2056)\n\npiste_sfc\n\nGeometry set for 1 feature \nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 2682705 ymin: 1255553 xmax: 2684336 ymax: 1258929\nProjected CRS: CH1903+ / LV95\n\n\n\n\nflughafen_sfc &lt;- st_sfc(flughafen, crs = 2056)\n\nflughafen_sfc\n\nGeometry set for 1 feature \nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2682534 ymin: 1255702 xmax: 2685600 ymax: 1259699\nProjected CRS: CH1903+ / LV95",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "week-1-simple-features.html#sf-simple-features",
    "href": "week-1-simple-features.html#sf-simple-features",
    "title": "Simple Features",
    "section": "sf: Simple features",
    "text": "sf: Simple features\n\nSimple features have attributes\nIn order to add attributes to a simple feature column (sfc), we need to convert it to a simple feature (sf)\n\n\nfracht_sf &lt;- st_sf(fracht_sfc)\n\nfracht_sf$name &lt;- \"Ost\"\n\n\nA sf class is a subset (i.e.¬†special case) of the class data.frame.\nMost things which can be done with a data.frame, can be done with an sf object as well\nMany tidyverse functions are implemented to nicely work with sf\n\n\n# sf objects are also dataframes\nis.data.frame(fracht_sf)\n\n[1] TRUE\n\n\n\n\nNote: Geometries are sticky. This means they aren‚Äôt dropped implicitly\n\n\n# Geometries are sticky\nfracht_sf[, \"name\"] \n\nSimple feature collection with 1 feature and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 2685374 ymin: 1256519 xmax: 2685374 ymax: 1256519\nProjected CRS: CH1903+ / LV95\n  name              fracht_sfc\n1  Ost POINT (2685374 1256519)\n\n\n\n\npiste_sf &lt;- st_sf(piste_sfc)\n\npiste_sf$nr &lt;- 34\n\nflughafen_sf &lt;- st_sf(flughafen_sfc)\n\nflughafen_sf$name &lt;- \"Flughafen Z√ºrich\"\n\nflughafen_sf\n\nSimple feature collection with 1 feature and 1 field\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2682534 ymin: 1255702 xmax: 2685600 ymax: 1259699\nProjected CRS: CH1903+ / LV95\n                   flughafen_sfc             name\n1 POLYGON ((2684142 1255702, ... Flughafen Z√ºrich",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "week-1-simple-features.html#sec-plotting",
    "href": "week-1-simple-features.html#sec-plotting",
    "title": "Simple Features",
    "section": "Plotting simple features",
    "text": "Plotting simple features\n\nVarious libraries support plotting sf objects:\n\nbase R (sf provides a plot-method)\nGeneral purpose libraries such as ggplot2\nDedicated geospatial plotting libraries such as tmap\n\nUse:\n\nbase R: If you want to take a quick look at your data. Base R has the most compact syntax and is extremely fast in plotting\nggplot2: If you only have (small-ish) vector data (no raster) and/or want to leverage the power of ggplot2\ntmap: If you want to use all features a dedicated library for geospatial data has to offer: North arrow, scale bar, interactive (web) maps\n\n\n#\n# Using base R\nplot(st_geometry(flughafen_sf))\nplot(piste_sf, add = TRUE)\nplot(fracht_sf, add = TRUE)\n#\n# Using ggplot2\nlibrary(ggplot2)\nggplot() +\n  geom_sf(data = flughafen_sf) +\n  geom_sf(data = piste_sf) +\n  geom_sf(data = fracht_sf)\n#\n# Using tmap\nlibrary(tmap)\ntm_shape(flughafen_sf) + tm_polygons() +\n  tm_shape(piste_sf) + tm_lines() +\n  tm_shape(fracht_sf) + tm_dots()\n\n\n\n\n\n\nbase R\n\n\n\n\n\n\n\nlibrary ggplot2\n\n\n\n\n\n\n\nlibrary tmap",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "week-1-simple-features.html#sec-plotting-interactive",
    "href": "week-1-simple-features.html#sec-plotting-interactive",
    "title": "Simple Features",
    "section": "Interactive maps",
    "text": "Interactive maps\nThe tmap library can render the map either in a static plot as above (the default) or as an interactive web map (see below)\n\n# set tmap_mode to \"view\" for an interactive web map\ntmap_mode(\"view\")\n\ntm_shape(flughafen_sf) + tm_polygons() +\n  tm_shape(piste_sf) + tm_lines() +\n  tm_shape(fracht_sf) + tm_dots()",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "week-1-simple-features.html#exercises",
    "href": "week-1-simple-features.html#exercises",
    "title": "Simple Features",
    "section": "Exercises",
    "text": "Exercises\n\nCreate some simple feature geometries (sfg) of objects you know ‚Äúby hand‚Äù\n\n\nCreate at least one POINT, one LINESTRING and one POLYGON geometry\nYou can capture the coordinates of the nodes from map.geo.admin if these are is Switzerland and openstreetmap (or similar) if they aren‚Äôt\n\n\nCreate simple feature columns from you sfgs. Make sure that you assign the correct CRS\nCreate simple features (sf) from your sfcs and add some attributes\n\n\n\n\n\nDorman, Michael. 2023. ‚ÄúSpatial Data Programming with Python ‚Äî Geobgu.xyz.‚Äù https://geobgu.xyz/py/.\n\n\nPebesma, Edzer. 2018. ‚ÄúSimple Features for R: Standardized Support for Spatial Vector Data.‚Äù The R Journal 10 (1): 439‚Äì46. https://doi.org/10.32614/RJ-2018-009.",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "week-1-simple-features.html#footnotes",
    "href": "week-1-simple-features.html#footnotes",
    "title": "Simple Features",
    "section": "",
    "text": "non-selfintersecting‚Ü©Ô∏é\nnon-selfintersecting‚Ü©Ô∏é\nthe first ring denotes the exterior ring, zero or more subsequent rings denote holes in this exterior ring‚Ü©Ô∏é",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "week-1-vector-io.html",
    "href": "week-1-vector-io.html",
    "title": "Vector data I/O",
    "section": "",
    "text": "GDAL / ogr2ogr\nGDAL:",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector data I/O</span>"
    ]
  },
  {
    "objectID": "week-1-vector-io.html#sec-gdal-ogr2ogr",
    "href": "week-1-vector-io.html#sec-gdal-ogr2ogr",
    "title": "Vector data I/O",
    "section": "",
    "text": "is an open source translator library for raster and vector geospatial data formats.\nstands for Geospatial Data Abstraction Library\nis used in most geospatial software, be it FOSS or proprietary. The list includes: ArcGIS, QGIS, R (sf) and Python (geopandas)",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector data I/O</span>"
    ]
  },
  {
    "objectID": "week-1-vector-io.html#gdal-vector-drivers-read",
    "href": "week-1-vector-io.html#gdal-vector-drivers-read",
    "title": "Vector data I/O",
    "section": "GDAL Vector drivers (read)",
    "text": "GDAL Vector drivers (read)\n\nSince GDAL supports a long list of different geospatial file formats, all are in turn supported by {sf}\nRun the function st_drivers for a full list\n{sf} tries to guess the correct driver based on the file extension (see below)\n\n\n# sf uses the geojson driver, based on the file extension\nstationen_schweiz &lt;- read_sf(\"data/week1-exercises/stationen_schweiz.geojson\")\n\n\n# sf uses the shapefile driver, based on the file extension\nhoheitsgebiet &lt;- read_sf(\"data/week1-exercises/HOHEITSGEBIET_FR.shp\")\n\n\nThe read_sf() function is a wrapper around the st_read() function, which is the actual function that reads the data. I use read_sf since this wrapper‚Äôs default value for the quiet argument is TRUE (less verbose)",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector data I/O</span>"
    ]
  },
  {
    "objectID": "week-1-vector-io.html#multiple-layers-in-one-file",
    "href": "week-1-vector-io.html#multiple-layers-in-one-file",
    "title": "Vector data I/O",
    "section": "Multiple layers in one file",
    "text": "Multiple layers in one file\n\nSome file formats, e.g.¬†Geopackages (*.gpkg) or Geodatabases (*.gdb) support multiple datasets in a single file.\nIf no specific layer is requested read_sf() will import the first available layer\nIf more than 1 layers are available, read_sf() will return a warning\nThe function st_layers() will list all available layers\n\n\ntlm3d_path &lt;- \"data/week1-exercises/swiss_TLM3D.gpkg\"\n\n# Note the warning\ntlm3d &lt;- read_sf(tlm3d_path)\n\nWarning in CPL_read_ogr(dsn, layer, query, as.character(options), quiet, :\nautomatically selected the first layer in a data source containing more than\none.\n\n\n\n\n# This will list all layers, including some metadata\nst_layers(tlm3d_path)\n\nDriver: GPKG \nAvailable layers:\n  layer_name    geometry_type features fields       crs_name\n1     tlm_bb 3D Multi Polygon    49321     14 CH1903+ / LV95\n2      dummy            Point        3      0 CH1903+ / LV95\n\n\n\ntlm_bb &lt;- read_sf(tlm3d_path, \"tlm_bb\")",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector data I/O</span>"
    ]
  },
  {
    "objectID": "week-1-vector-io.html#sql-queries-during-import",
    "href": "week-1-vector-io.html#sql-queries-during-import",
    "title": "Vector data I/O",
    "section": "SQL queries during import",
    "text": "SQL queries during import\n\nread_sf() understands an Spatialite SQL query provided in the query = argument\nIn case query = is used, the layers = argument should be skipped (since the layers is specified in the query)\n\n\ntlm_seen &lt;- read_sf(\n  tlm3d_path, \n  query = \"SELECT objektart, geom FROM tlm_bb WHERE objektart = 'Stehende Gewaesser'\"\n  )",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector data I/O</span>"
    ]
  },
  {
    "objectID": "week-1-vector-io.html#gdal-vector-drivers-write",
    "href": "week-1-vector-io.html#gdal-vector-drivers-write",
    "title": "Vector data I/O",
    "section": "GDAL Vector drivers (write)",
    "text": "GDAL Vector drivers (write)\n\nThe function st_write() is used to export an sf object to file\nMost vector drivers support reading and writing (see st_drivers / column write)\nMany file formats support appending to the dataset (see append =)\n\n\nst_write(tlm_seen, \"data-out/seen.geojson\")\n\nWriting layer `seen' to data source `data-out/seen.geojson' using driver `GeoJSON'\nWriting 1189 features with 1 fields and geometry type 3D Multi Polygon.",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector data I/O</span>"
    ]
  },
  {
    "objectID": "week-1-spatial-operations.html",
    "href": "week-1-spatial-operations.html",
    "title": "Spatial Vector Operation",
    "section": "",
    "text": "Thematic queries\nlibrary(sf)\n\ntlm3d_path &lt;- \"data/week1-exercises/swiss_TLM3D.gpkg\"\n\ntlm_seen &lt;- read_sf(\n  tlm3d_path, \n  query = \"SELECT objektart, geom FROM tlm_bb WHERE objektart = 'Stehende Gewaesser'\"\n  )\ntlm_bb &lt;- read_sf(tlm3d_path, \"tlm_bb\")\n\n# Subsetting with base-R\ntlm_seen &lt;- tlm_bb[tlm_bb$objektart == \"Stehende Gewaesser\", ]\n\n\nlibrary(dplyr)\n\n\n# Subsetting using dplyr::filter\ntlm_seen &lt;- filter(tlm_bb, objektart == \"Stehende Gewaesser\")",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Spatial Vector Operation</span>"
    ]
  },
  {
    "objectID": "week-1-spatial-operations.html#thematic-queries",
    "href": "week-1-spatial-operations.html#thematic-queries",
    "title": "Spatial Vector Operation",
    "section": "",
    "text": "SQL queries can be performed with file import\n\n\n\nHowever, datasets can also be queried after import using data.frame methods (such as [ or dplyr::filter)",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Spatial Vector Operation</span>"
    ]
  },
  {
    "objectID": "week-1-spatial-operations.html#sec-spatiao-queries",
    "href": "week-1-spatial-operations.html#sec-spatiao-queries",
    "title": "Spatial Vector Operation",
    "section": "Spatial queries using binary predicate functions",
    "text": "Spatial queries using binary predicate functions\nTake the following example:\n\nSelect all forests in the canton of Luzern\n\n\nSpatial query functions include: st_contains(), st_intersects(), st_touches(), st_within(), and many more\nThese spatial queries are called geometric binary predicates\nThis family of functions return so called sparse matrices: a list the same length as x, which, for each element in x, contains the indices of y where the condition is met.\nThey could return cross matrices, but these usually have a larger memory, since they have are \\(x \\times y\\) in size\n\n\n\nluzern &lt;- read_sf(\"data/week1-exercises/luzern.gpkg\")\n\ntlm_wald &lt;- filter(tlm_bb, objektart == \"Wald\")\n\n# The dataset already has this crs (2056), but apparently \n# does not realize this\ntlm_wald &lt;- st_set_crs(tlm_wald, 2056)\n\n\nquery_res &lt;- st_intersects(tlm_wald, luzern)\n\n# Note the length of the output equals nrow(tlm_wald)\nquery_res\n\nSparse geometry binary predicate list of length 8096, where the\npredicate was `intersects'\nfirst 10 elements:\n 1: (empty)\n 2: (empty)\n 3: (empty)\n 4: (empty)\n 5: (empty)\n 6: (empty)\n 7: (empty)\n 8: (empty)\n 9: (empty)\n 10: (empty)\n\n\n\n(The first 10 elements are empty, because to not intersect Luzern)\nThis list can be used to subset x (TRUE where the list is not empty):\n\n\n\n# Note the use of lenghts (with an s) to get the length of each element in the \n# list\nwald_luzern &lt;- tlm_wald[lengths(query_res) &gt; 0,]\n\n\nlibrary(ggplot2)\n\n\nggplot(luzern) + \n  geom_sf(data = wald_luzern, fill = \"darkgreen\") +\n  geom_sf(color = \"red\", fill = NA) \n\n\n\n\n\n\n\nFigure¬†3.1: Note how some forests are outside the canton‚Äôs border. This is the nature of st_intersects. If even a small part of a forest feature is within Luzern, this feature intersects Luzern and is therefore retained. To query only forests that are completly within Luzern, use st_within().",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Spatial Vector Operation</span>"
    ]
  },
  {
    "objectID": "week-1-spatial-operations.html#spatial-queries-using-or-st_filter",
    "href": "week-1-spatial-operations.html#spatial-queries-using-or-st_filter",
    "title": "Spatial Vector Operation",
    "section": "Spatial queries using [ or st_filter",
    "text": "Spatial queries using [ or st_filter\nThe code above was for illustration purposes. The code can be written more concise:\n\n# using sf-methods in base-R\ntlm_wald[luzern,, op = st_intersects]\n\n# using st_filter\nst_filter(tlm_wald, luzern, .predicate = st_intersects)\n\nThe default value for op and .predicate is st_intersects, so these arguments could also have been omitted:\n\n# using sf-methods in base-R\ntlm_wald[luzern,,]\n\n# using st_filter\nst_filter(tlm_wald, luzern)",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Spatial Vector Operation</span>"
    ]
  },
  {
    "objectID": "week-1-spatial-operations.html#overlay-analysis",
    "href": "week-1-spatial-operations.html#overlay-analysis",
    "title": "Spatial Vector Operation",
    "section": "Overlay Analysis",
    "text": "Overlay Analysis\n\nIn the example illustrated in Figure¬†3.1, we have the choice of subsetting forests that either intersect Luzern ever so slightly (st_intersects), or that lie completely within Luzern (st_within).\nDepending on the question, both options can be unsatisfactory (e.g.¬†if the question was Which percentage of Luzern is covered by forest?)\nFor some cases, it might be necessary to ‚Äúcut‚Äù the forest area at the cantons border\nThis can be achieved with st_intersection (which is different from intersects)\nThere are several other functions that work on pairs of geometries. See Geometric operations on pairs of simple feature geometry sets\nThere are even more functions that work on single geometries, e.g.¬†st_buffer. See Geometric unary operations on simple feature geometry sets\n\n\n\nlibrary(glue)\nlibrary(scales)\nwald_luzern2 &lt;- st_intersection(luzern, wald_luzern)\n\nggplot(luzern) + \n  geom_sf(fill = \"gray\", color = NA) +\n  geom_sf(data = wald_luzern2, fill = \"darkgreen\", color = NA)\n\n\n\n\n\n\n\n\n\nNow, it‚Äôs possible to compute the area of Luzern and the forest that intersects Luzern using the function st_area.\nThere are several functions to compute geometric measurements of sf-objects.\n\n\nsum(st_area(wald_luzern2))/st_area(luzern)\n\n0.2721733 [1]",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Spatial Vector Operation</span>"
    ]
  },
  {
    "objectID": "week-1-task.html",
    "href": "week-1-task.html",
    "title": "üöÄ Tasks",
    "section": "",
    "text": "Task 1.1\nOn GitHub:\nOn your local machine:",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>üöÄ Tasks</span>"
    ]
  },
  {
    "objectID": "week-1-task.html#sec-gh-pages",
    "href": "week-1-task.html#sec-gh-pages",
    "title": "üöÄ Tasks",
    "section": "",
    "text": "On GitHub, create a free organisation called ADLS-STDS2025-kuerzel (replace kuerzel with your ZHAW email prefix).\nSubmit the URL to this organisation to us via mail\nIn this Organisation, create a new, blank repository called week-1.\n\n\n\nInstall CLI Software quarto\nCreate a new directory to solve this weeks task.\nMake this folder a git repository (git init) and use the GitHub Repo you created previously as a remote (git remote add origin &lt;URL&gt;)\nCreate a new file called _quarto.yml with the content as shown below\nCreate a new quarto file called index.qmd with the content as shown below\nRun the CLI command quarto preview to preview the document\nRun the CLI command quarto publish gh-pages to publish the document to GitHub Pages\n\n\n\n_quarto.yml\n\nproject:\n  output-dir: _docs\n\n\n\nindex.qmd\n\n# Solution for Week1: Vector data processing\n   \nIn this document, I solve the tasks for week 1 of the course \n*Spatiotemporal Datascience*",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>üöÄ Tasks</span>"
    ]
  },
  {
    "objectID": "week-1-task.html#sec-vec-basic",
    "href": "week-1-task.html#sec-vec-basic",
    "title": "üöÄ Tasks",
    "section": "Task 1.2",
    "text": "Task 1.2\n\nDownload the datasets swissTLM3D and swissboundaries3d from swisstopo.\nAdd the datasets to the local folder you created above, in a subfolder named data\nAdd the data folder to the .gitignore file.\nIn index.qmd, add a code chunk (R or Python) and solve the following tasks using your preferred language.\nUsing swissTLM3d and swissboundaries3d, calculate the percentage of area covered by forest per canton\nVisualize the results (in a map and / or a plot)\nRender the document using quarto preview\nPublish your result using quarto publish gh-pages\n\nA code chunk is added in the following manner. Please consult the Quarto - Getting Started for more information on your local setup.\n\n\nindex.qmd\n\n# Solution for Week1: Vector data processing\n   \nIn this document, I solve the tasks for week 1 of the course \n*Spatiotemporal Datascience*\n\n```{r}\nlibrary(sf)\n\n```",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>üöÄ Tasks</span>"
    ]
  },
  {
    "objectID": "week-2.html",
    "href": "week-2.html",
    "title": "Week 2: Geopython Conference",
    "section": "",
    "text": "The concepts of this course are implemented in the programming language R. However, these concepts can be transferred to other programming languages, such as Python and vice versa. For this reason, we will take the opportunity that the 2025 Geopython conference is taking place this week, and some talks are during the course time.\nAn online ticket will be provided to all participants. If you want to attend the conference in person, you will have to pay for the ticket yourself.\nYour assignment (not marked) is to watch at least the talks listed in Table¬†5.1. We will discuss them the following week. Feel free to watch other topics listed in the conference program.\n\n\n\nTable¬†5.1: Assigned talks at the Geopython conference\n\n\n\n\n\n\n\n\n\nTime\nTalk\n\n\n\n\n09:15‚Äì09:45\nThe earth is not flat! Introducing Spherely and support for spherical geometries in geopandas\n\n\n09:45‚Äì10:15\nduckdb-geography: Global vector data in DuckDB\n\n\n11:15‚Äì11:45\nScaling Geospatial Techniques to Cloud-Native Platforms",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Week 2: Geopython Conference</span>"
    ]
  },
  {
    "objectID": "week-3-raster-io.html",
    "href": "week-3-raster-io.html",
    "title": "Raster Data I/O",
    "section": "",
    "text": "Import a raster file\nlibrary(terra)\n\ndhm25 &lt;- rast(\"data/week3-exercises/dhm25_lu.tif\")\ndhm25\n\nclass       : SpatRaster \ndimensions  : 2321, 2161, 1  (nrow, ncol, nlyr)\nresolution  : 25, 25  (x, y)\nextent      : 2628987, 2683012, 1179988, 1238013  (xmin, xmax, ymin, ymax)\ncoord. ref. : CH1903+ / LV95 (EPSG:2056) \nsource      : dhm25_lu.tif \nname        : dhm25_lu \nmin value   :    381.1 \nmax value   :   3228.3",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Raster Data I/O</span>"
    ]
  },
  {
    "objectID": "week-3-raster-io.html#import-a-raster-file",
    "href": "week-3-raster-io.html#import-a-raster-file",
    "title": "Raster Data I/O",
    "section": "",
    "text": "terra uses the function rast() to import raster data\nPrinting the object will give you some basic information about the raster\n\nThe number of rows and columns, as well as the number of layers\nThe resolution of the raster, meter per pixel (25 in our case)\nThe extent of the raster, in the coordinate reference system of the raster\nThe coordinate reference system (CRS) of the raster\nThe source (in memory, or a file path)\nThe name(s) of the band(s) (we only have one band in our case)\nThe min and max values of the raster",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Raster Data I/O</span>"
    ]
  },
  {
    "objectID": "week-3-raster-io.html#geotiff",
    "href": "week-3-raster-io.html#geotiff",
    "title": "Raster Data I/O",
    "section": "GeoTIFF",
    "text": "GeoTIFF\n\nGeoTIFF is the most common raster format\nGeoTIFF is an extension to the TIFF format, which includes additional metadata to establish the spatial reference of the file\nThis includes the CRS, the extent, the resolution, and the origin of the raster\nThe metadata is either stored in the header of the file, or in an accompanying file with the same name, but different extension (.tfw or .aux.xml)\nOther important raster file formats include:\n\nCloud optimized GeoTIFF (COG): A GeoTIFF file that is optimized for cloud storage which allows for efficient, partial reading of the file over HTTP\nJPG2000 (.jp2) is a compressed raster format that is often used for satellite imagery\nNetCDF (.nc) is a format that is often used for climate data\nHDF5 (.h5) is a format that is often used for remote sensing data",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Raster Data I/O</span>"
    ]
  },
  {
    "objectID": "week-3-raster-io.html#writing-a-raster-file",
    "href": "week-3-raster-io.html#writing-a-raster-file",
    "title": "Raster Data I/O",
    "section": "Writing a raster file",
    "text": "Writing a raster file\n\nYou can write a raster object to a file using the writeRaster() function\n\n\nwriteRaster(dhm25, \"data-out/dhm25_lu.tif\", overwrite = TRUE)",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Raster Data I/O</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html",
    "href": "week-3-raster-operations.html",
    "title": "Raster Operations",
    "section": "",
    "text": "Introduction",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#introduction",
    "href": "week-3-raster-operations.html#introduction",
    "title": "Raster Operations",
    "section": "",
    "text": "Map algebra can be defined as operations that modify or summarize raster cell values, with reference to surrounding cells, zones, or statistical functions that apply to every cell.\nMap algebra divides raster operations into four subclasses:\n\nLocal or per-cell operations\nFocal or neighborhood operations. Most often the output cell value is the result of a 3 x 3 input cell block\nZonal operations are similar to focal operations, but the surrounding pixel grid on which new values are computed can have irregular sizes and shapes\nGlobal or per-raster operations. That means the output cell derives its value potentially from one or several entire rasters",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#global-operation-1",
    "href": "week-3-raster-operations.html#global-operation-1",
    "title": "Raster Operations",
    "section": "Global Operation (1)",
    "text": "Global Operation (1)\n\nThe most common global operations are descriptive statistics for the entire raster dataset such as the minimum, maximum or mean value.\nFor example: What is the mean elevation value for Luxembourg?\n\n\n\n\n\n\n\n\n\nFigure¬†7.1: Elevation of Luxembourg\n\n\n\n\n\n\n# note: mean(r) does not work, since \"mean\" is used as a local operator\nmean_elev &lt;- global(r, mean, na.rm = TRUE)\n\nmean_elev\n\n              mean\nelevation 347.6488",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#sec-global-2",
    "href": "week-3-raster-operations.html#sec-global-2",
    "title": "Raster Operations",
    "section": "Global Operation (2)",
    "text": "Global Operation (2)\n\nAnother type of ‚Äúglobal‚Äù operation is distance\nThis function calculates the distance from each cell to a specific target cell\nFor example, what is the distance from each cell to Luxembourg City, the capital of Luxembourg?\n\n\n\n\n\n\n\n\n\n\n\nr_dist &lt;- distance(r, luxembourg_city)\nr_dist &lt;- mask(r_dist, r)",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#sec-zonal-1",
    "href": "week-3-raster-operations.html#sec-zonal-1",
    "title": "Raster Operations",
    "section": "Zonal",
    "text": "Zonal\n\nZonal operations apply an aggregation function to multiple raster cells\nA second raster with categorical values define the ‚Äúzones‚Äù\n\nWhat is the mean altitude per municipality?\n\nmean_vals &lt;- zonal(r, zones, fun = mean, na.rm = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†7.2: The original Zones (E.g. municipalities of Luxembourg)\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†7.3: Mean elevation per zone / per municipality\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\n\nThe global operation can be seen as a special case of a zonal operation, where the only ‚ÄúZone‚Äù is the entire dataset",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#local-1",
    "href": "week-3-raster-operations.html#local-1",
    "title": "Raster Operations",
    "section": "Local (1)",
    "text": "Local (1)\n\nLocal operations comprise all cell-by-cell operations in one or several layers.\nFor example, we can classify the elevation into values above and below a certain threshold\n\n\n# first, create a boolean copy of the raster\nr_bool &lt;- as.logical(r)\n\nmean_elev &lt;- as.numeric(mean_elev)\nmean_elev\n\n[1] 347.6488\n\nr_bool[r &gt; mean_elev] &lt;- FALSE\nr_bool[r &lt;= mean_elev] &lt;- TRUE",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#local-2",
    "href": "week-3-raster-operations.html#local-2",
    "title": "Raster Operations",
    "section": "Local (2)",
    "text": "Local (2)\n\nThis type of (re-) classification is a very common operation\nFor more than 2 categories, we can use classify\n\n\ncuts &lt;- global(r, quantile, probs = c(0, .33, .66, 1), na.rm = TRUE)\n\nr_classify &lt;- classify(r, as.numeric(cuts))\n\n# this next line just replaces the default labels with some custom ones\nlevels(r_classify) &lt;- data.frame(ID = 0:2, category = c(\"low\",\"mid\",\"high\"))\n\np + tm_shape(r_classify) +\n    tm_raster(style = \"cat\",legend.show = TRUE, palette = \"viridis\", title = \"Elevation\") +\n    tm_layout(legend.show = TRUE)",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#local-3",
    "href": "week-3-raster-operations.html#local-3",
    "title": "Raster Operations",
    "section": "Local (3)",
    "text": "Local (3)\n\nLocal operations are often used with multiple bands\nFor example, we could calculate the mean intensity values of red, green and blue:\n\n\nl7 &lt;- rast(system.file(\"tif/L7_ETMs.tif\",package = \"stars\"))\n\nnames(l7) &lt;- c(\"B\", \"G\", \"R\", \"NIR\", \"SWIR\", \"MIR\")\n\nl7_rgb &lt;- l7[[c(\"R\",\"G\", \"B\")]]\n\nplot(l7_rgb, nr = 1)\n\n\n\n\n\n\n\n\n\nl7_rgb_mean &lt;- mean(l7_rgb)\n\nplot(l7_rgb_mean)",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#local-4",
    "href": "week-3-raster-operations.html#local-4",
    "title": "Raster Operations",
    "section": "Local (4)",
    "text": "Local (4)\n\nIn a more complex usecase, we could use the R, G and B band to calculate a grayscale value (\\(L^*\\)) using the following formula (from here):\n\n\\[\\begin{aligned}\n\nL^* &= 116 \\times Y ^ {\\frac{1}{3}} - 16\\\\\n\nY &= 0.2126 \\times R^\\gamma+0.7152 \\times G^\\gamma+0.0722 \\times B^\\gamma \\\\\n\n\n\\gamma &= 2.2\n\n\\end{aligned}\\]\n\ng &lt;- 2.2\n\nl7 &lt;- l7/255 # scale values to 0-1 (probabbly not necessary)\n\nY &lt;- 0.2126 * l7[[\"R\"]]^g + 0.7152 * l7[[\"G\"]]^g + 0.0722 * l7[[\"B\"]]^g\n\nL &lt;- 116* Y^(1/3)-16\n\n# Plot the result",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#sec-focal-1",
    "href": "week-3-raster-operations.html#sec-focal-1",
    "title": "Raster Operations",
    "section": "Focal",
    "text": "Focal\n\nWhile local functions operate on one cell focal operations take into account a central (focal) cell and its neighbors.\nThe neighborhood (also named kernel, filter or moving window) under consideration is typically of size 3-by-3 cells (that is the central cell and its eight surrounding neighbors), but can take on any other size or shape as defined by the user.\nA focal operation applies an aggregation function to all cells within the specified neighborhood, uses the corresponding output as the new value for the central cell, and moves on to the next central cell\n\n\n\n\n\n\n\nFigure¬†7.4: Note how, depending on the size of your moving window, NA‚Äôs are produced. Source: Lovelace, Nowosad, and Muenchow (2019)\n\n\n\n\nfocal3by3 &lt;- matrix(rep(1,9), ncol = 3)\n\n\nfocal11by11 &lt;- matrix(rep(1,121), ncol = 11)\n\n\nr_foc3 &lt;- focal(r, focal3by3, fun = mean, fillNA = TRUE)\n\nr_foc11 &lt;- focal(r, focal11by11, fun = mean, fillNA = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†7.5: Original values\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†7.6: Result of a 3x3 Focal Window\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†7.7: Result of a 11x11 Focal Window\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\n\nNote how the output raster is smaller as the focal window is larger (edge effect)",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#focal-weights-1",
    "href": "week-3-raster-operations.html#focal-weights-1",
    "title": "Raster Operations",
    "section": "Focal weights (1)",
    "text": "Focal weights (1)\n\nThe focal weights we used above were square and evenly weighted\n\n\nfocal3by3\n\n     [,1] [,2] [,3]\n[1,]    1    1    1\n[2,]    1    1    1\n[3,]    1    1    1\n\n\n\nfocal11by11\n\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11]\n [1,]    1    1    1    1    1    1    1    1    1     1     1\n [2,]    1    1    1    1    1    1    1    1    1     1     1\n [3,]    1    1    1    1    1    1    1    1    1     1     1\n [4,]    1    1    1    1    1    1    1    1    1     1     1\n [5,]    1    1    1    1    1    1    1    1    1     1     1\n [6,]    1    1    1    1    1    1    1    1    1     1     1\n [7,]    1    1    1    1    1    1    1    1    1     1     1\n [8,]    1    1    1    1    1    1    1    1    1     1     1\n [9,]    1    1    1    1    1    1    1    1    1     1     1\n[10,]    1    1    1    1    1    1    1    1    1     1     1\n[11,]    1    1    1    1    1    1    1    1    1     1     1",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#focal-weights-2",
    "href": "week-3-raster-operations.html#focal-weights-2",
    "title": "Raster Operations",
    "section": "Focal weights (2)",
    "text": "Focal weights (2)\n\nHowever, we can also create uneven weights:\n\nFor example, a laplacian filter is commonly used for edge detection.\n\nlaplacian &lt;- matrix(c(0,1,0,1,-4,1,0,1,0), nrow=3) \n\nlaplacian\n\n     [,1] [,2] [,3]\n[1,]    0    1    0\n[2,]    1   -4    1\n[3,]    0    1    0\n\n\nSo are the sobel filters\n\nsobel_x &lt;- matrix(c(-1,-2,-1,0,0,0,1,2,1), nrow=3)\n\nsobel_x\n\n     [,1] [,2] [,3]\n[1,]   -1    0    1\n[2,]   -2    0    2\n[3,]   -1    0    1\n\nsobel_y &lt;- matrix(c(1,0,-1,2,0,-2,1,0,-1), nrow=3)\n\nsobel_y\n\n     [,1] [,2] [,3]\n[1,]    1    2    1\n[2,]    0    0    0\n[3,]   -1   -2   -1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†7.8: Laplacian Filter\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†7.9: Sobel (x-direction)\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†7.10: SObel (y-direction)",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#focal-weights-3",
    "href": "week-3-raster-operations.html#focal-weights-3",
    "title": "Raster Operations",
    "section": "Focal weights (3)",
    "text": "Focal weights (3)\n\nWe can also create specific shapes using weights\nWe don‚Äôt need to create these matrices by hand. Rather, we can use the function focalMat to create different shapes automatically\n\n\n# Note \n# - \"d\" is evaluated in the units of \"x\" (in our case: meters)\n# - The sum of all weights equals to 1\n# - Note how the corners receive a value of 0\nfocal_circle3000 &lt;- focalMat(x = r, d = 3000, \"circle\")\n\nfocal_circle3000\n\n           [,1]       [,2]       [,3]       [,4]       [,5]\n[1,] 0.00000000 0.00000000 0.03703704 0.00000000 0.00000000\n[2,] 0.03703704 0.03703704 0.03703704 0.03703704 0.03703704\n[3,] 0.03703704 0.03703704 0.03703704 0.03703704 0.03703704\n[4,] 0.03703704 0.03703704 0.03703704 0.03703704 0.03703704\n[5,] 0.03703704 0.03703704 0.03703704 0.03703704 0.03703704\n[6,] 0.03703704 0.03703704 0.03703704 0.03703704 0.03703704\n[7,] 0.00000000 0.00000000 0.03703704 0.00000000 0.00000000\n\n\n\n\n\n\n\nA visual representation of the matrix / filter above\n\n\n\n\n\nfocal_gauss1000 &lt;- focalMat(x = r, d = 1000, \"Gauss\")\n\nfocal_gauss1000\n\n            [,1]        [,2]        [,3]        [,4]        [,5]\n[1,] 0.000241551 0.001082556 0.001784834 0.001082556 0.000241551\n[2,] 0.002942693 0.013188236 0.021743725 0.013188236 0.002942693\n[3,] 0.013188236 0.059105572 0.097448614 0.059105572 0.013188236\n[4,] 0.021743725 0.097448614 0.160665602 0.097448614 0.021743725\n[5,] 0.013188236 0.059105572 0.097448614 0.059105572 0.013188236\n[6,] 0.002942693 0.013188236 0.021743725 0.013188236 0.002942693\n[7,] 0.000241551 0.001082556 0.001784834 0.001082556 0.000241551\n\n\n\n\n\n\n\nA visual representation of the matrix / filter above",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#focal-functions-in-terrain-processing",
    "href": "week-3-raster-operations.html#focal-functions-in-terrain-processing",
    "title": "Raster Operations",
    "section": "Focal functions in terrain processing",
    "text": "Focal functions in terrain processing\n\nFocal functions are used to calculate the slope of a specific location, e.g.¬†using the algorithm by Horn (1981)\nSimilarly, calculating the aspect (azimuth) of a location is a very typical task when dealing with elevation data\nThese algorithms are used so often, that they are implemented in a dedicated function (terrain())\n\nterrain(r, \"slope\") |&gt; plot()\nterrain(r, \"aspect\") |&gt; plot()\n\n\n\n\n\n\n\n\n\nFigure¬†7.11: Calculating slope using a predefined algorithm\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†7.12: Calculating aspect\n\n\n\n\n\n\n\n\n\n\nHorn, Berthold KP. 1981. ‚ÄúHill Shading and the Reflectance Map.‚Äù Proceedings of the IEEE 69 (1): 14‚Äì47.\n\n\nLovelace, Robin, Jakub Nowosad, and Jannes Muenchow. 2019. Geocomputation with r. Chapman; Hall/CRC.",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-vector-operations.html",
    "href": "week-3-raster-vector-operations.html",
    "title": "Raster-Vector Operations",
    "section": "",
    "text": "Two worlds of spatial data",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Raster-Vector Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-vector-operations.html#two-worlds-of-spatial-data",
    "href": "week-3-raster-vector-operations.html#two-worlds-of-spatial-data",
    "title": "Raster-Vector Operations",
    "section": "",
    "text": "Till now, we have treated vector and raster data separately\nHowever, in many cases, you will need to combine both types of data\nFor example, take the Zonal operation we discussed in the chapter Zonal: Typically, your ‚Äúzones‚Äù will be vector polygons",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Raster-Vector Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-vector-operations.html#zonal-operations-with-vector-data",
    "href": "week-3-raster-vector-operations.html#zonal-operations-with-vector-data",
    "title": "Raster-Vector Operations",
    "section": "Zonal operations with vector data",
    "text": "Zonal operations with vector data\n\nThe zonal function in {terra} can handle vector data: however, it requires sf objects to be converted to terra‚Äôs own vector format, called SpatVector. - The function vect() can be used to convert sf objects to SpatVector objects:\n\n\nzones\n\nSimple feature collection with 12 features and 1 field\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 49540.31 ymin: 57009.53 xmax: 105922 ymax: 138631.1\nProjected CRS: LUREF / Luxembourg TM\n# A tibble: 12 √ó 2\n   zone                                                                 geometry\n * &lt;chr&gt;                                                           &lt;POLYGON [m]&gt;\n 1 Capellen         ((67807.54 74157.87, 67831.1 74087.81, 67898.55 73957.4, 67‚Ä¶\n 2 Clervaux         ((76452.54 123066.7, 76921.51 122665.9, 76473.69 122657.2, ‚Ä¶\n 3 Diekirch         ((87698.16 101220.4, 87632.77 101114.2, 87519.26 100859, 87‚Ä¶\n 4 Echternach       ((101054.8 98587.69, 101873.3 98671.15, 102308.8 98302.53, ‚Ä¶\n 5 Esch-sur-Alzette ((70485.31 57109.03, 70479.23 57110.74, 70124.08 57203.85, ‚Ä¶\n 6 Grevenmacher     ((98316.48 77592.6, 98370.24 76804.03, 98372.67 76767.55, 9‚Ä¶\n 7 Luxembourg       ((79432.03 68509.55, 79342.29 68579.14, 79284.43 68609.69, ‚Ä¶\n 8 Mersch           ((81080.72 86671, 81039.57 86437.63, 81015.75 86030.31, 810‚Ä¶\n 9 Redange          ((66884.63 90450.9, 66949.54 90334.49, 67033.38 90124.69, 6‚Ä¶\n10 Remich           ((94804.67 63851.75, 94253.56 63591.47, 94439.38 62504.97, ‚Ä¶\n11 Vianden          ((84572.47 109652.3, 84752.39 109225.1, 84638.88 108774.4, ‚Ä¶\n12 Wiltz            ((69104.29 107418.7, 68964.91 107123.7, 68930.58 106984.6, ‚Ä¶\n\nmean_vals &lt;- zonal(r, vect(zones), fun = mean, na.rm = TRUE)\n\n\nzones$mean &lt;- mean_vals$elevation\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†8.1: The original raster data\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†8.2: The original zones as vector polygons\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†8.3: The resulting zones (mean elevation per zone), also as vector data",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Raster-Vector Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-vector-operations.html#extracting-raster-values-at-vector-points",
    "href": "week-3-raster-vector-operations.html#extracting-raster-values-at-vector-points",
    "title": "Raster-Vector Operations",
    "section": "Extracting raster values at vector points",
    "text": "Extracting raster values at vector points\n\nA another common operation is to extract raster values at specific points\nLet‚Äôs take the example of the city of Luxembourg (see Global Operation (2))\nThe function extract() can be used to extract raster values at specific points\nextract returns a data.frame with\n\none column per raster band (1 in our case)\none row per point (also 1 in our case):\n\n\n\n\n\n\n\n\n\n\n\n\nlux_elev &lt;- extract(r, luxembourg_city)\nlux_elev\n\n  ID elevation\n1  1  293.9805",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Raster-Vector Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-vector-operations.html#vector-to-raster-conversion",
    "href": "week-3-raster-vector-operations.html#vector-to-raster-conversion",
    "title": "Raster-Vector Operations",
    "section": "Vector to raster conversion",
    "text": "Vector to raster conversion\n\nFunctions that combine raster and vector data usually convert vector to raster internally\nSometimes, we might want to do this conversion explicitly. This can be done using the rasterize() function\nThis function takes three arguments:\n\nx: The vector data (either of class sf or SpatVector)\ny: A raster object that defines the extent, resolution, and CRS of the resulting raster (i.e.¬†a ‚Äútemplate‚Äù)\nfield: The name of the column in the vector data that should be used to fill the raster cells\n\n\n\n# we can create a template using the input vector. All we have to specify \n# is the resolution of the output raster, which is evalutated in the units of\n# the CRS of the input vector data (meters in our case).\n\ntemplate &lt;- rast(zones, resolution = 1000)\n\nzones_raster &lt;- rasterize(zones, template, \"zone\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) The original zones as polygon data\n\n\n\n\n\n\n\n\n\n\n\n(b) The zones as raster data\n\n\n\n\n\n\n\nFigure¬†8.4: Note how the conversion to polygons results in a loss of detail\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote that rasters don‚Äôt store character information. The above zones are coded as integers with a corresponding look-up table (see ?terra::levels).",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Raster-Vector Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-vector-operations.html#raster-to-vector-conversion",
    "href": "week-3-raster-vector-operations.html#raster-to-vector-conversion",
    "title": "Raster-Vector Operations",
    "section": "Raster to vector conversion",
    "text": "Raster to vector conversion\n\nThe opposite operation, converting raster data to vector data, can be done using the {terra} functions as.points, as.lines and as.polygons:\nThe resulting object will be of class SpatVector. This can be converted to the sf class using st_as_sf()\n\n\nzones_poly &lt;- as.polygons(zones_raster) |&gt; \n  st_as_sf()\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) The zones as raster data\n\n\n\n\n\n\n\n\n\n\n\n(b) The zones as polygon data\n\n\n\n\n\n\n\nFigure¬†8.5: Note how the conversion back to polygons preserves the cell boundaries",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Raster-Vector Operations</span>"
    ]
  },
  {
    "objectID": "week-3-task.html",
    "href": "week-3-task.html",
    "title": "üöÄ Tasks",
    "section": "",
    "text": "Task 3.1\nFollow the instructions in Task 1.1 from Week 1 to create a new repo in the existing organization. As you did last week, solve the next task in a file named index.qmd.",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>üöÄ Tasks</span>"
    ]
  },
  {
    "objectID": "week-3-task.html#sec-task-rast-basic",
    "href": "week-3-task.html#sec-task-rast-basic",
    "title": "üöÄ Tasks",
    "section": "",
    "text": "Redo Task 1.2. However, rather than doing it using vector data, convert the data to raster and do the calculations in raster format.\nUsing the R package tictoc, measure the execute time of each step in the process. Do this for the raster approach and for the vector approach from last week.\nCompare the execution times of the two approaches. Which approach is faster? Where is the bottleneck?\nCompare the results of the two approaches. Are they the same? If not, why?",
    "crumbs": [
      "Week 3: Raster Recap",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>üöÄ Tasks</span>"
    ]
  },
  {
    "objectID": "week-4-topological-rel.html",
    "href": "week-4-topological-rel.html",
    "title": "Topological relations",
    "section": "",
    "text": "Named topological relations",
    "crumbs": [
      "Week 4: Vector Advanced",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Topological relations</span>"
    ]
  },
  {
    "objectID": "week-4-topological-rel.html#named-topological-relations",
    "href": "week-4-topological-rel.html#named-topological-relations",
    "title": "Topological relations",
    "section": "",
    "text": "We briefly touched topological relations in Spatial queries using binary predicate functions\nTopological relations describe the spatial relationships between objects.\nThey are also called binary topological relationships or binary predicates\nThey are logical statements (TRUE/FALSE) about the spatial relationships between two objects\nThe two objects are defined by ordered sets of points (typically forming points, lines and polygons) in two or more dimensions (Egenhofer and Herring 1990).\n\n\nUsage\n\nTopological relations can be used to subset or join spatial data\nFor example:\n\nSubsetting: Return all rivers that flow through the canton of Zurich\nJoining: For every train station, give me the name of the municipality it lies within\n\n\n\n\nNamed topological relations (I)\n\nThe most common topological relations are offered as functions / tools in most GIS software\nIn sf, the following topological functions are available:\n\nst_intersects()\nst_disjoint()\nst_touches()\nst_crosses()\nst_within()\nst_contains()\nst_contains_properly()\nst_overlaps()\nst_equals()\nst_covers()\nst_covered_by()\nst_equals_exact()\nst_is_within_distance()\n\nThese all work slightly differently, and are used in different contexts.\nFor example:\n\nst_covers() returns TRUE if no points of x are outside y, and at least one point of x is inside y.\nst_touches() returns TRUE if the geometries have at least one point in common, but their interiors do not intersect.\n\n\n\n\nNamed topological relations (II)\n\nSome of the relations mentioned above are symmetrical (the order of the geometries does not matter)\nFor example, if st_touches(x, y) is TRUE, then st_touches(y, x) is also TRUE\nOthers are not, meaning that the order of the geometries is important.\nFor example, st_contains(x, y) returns TRUE if x contains y, but st_contains(y, x) returns FALSE\nSome of the relations require additional arguments, such as st_is_within_distance(), which requires a distance argument\nYou can find the full list of topological relations in the sf documentation using ?geos_binary_pred\n\n\n\nSubset Examples\n\nLet‚Äôs take the example of the playgrounds in Zurich and the public transport stops.\nWe can subset the playground data to only include playgrounds that are close (e.g.¬†100m) to public transport stops\n\n\nlibrary(sf)\nlibrary(readr)\n# source: https://www.stadt-zuerich.ch/geodaten/\nplaygrounds &lt;- read_sf(\"data/week4-exercises/playgrounds.gpkg\")\npublictransport &lt;- read_sf(\"data/week4-exercises/public_transport.gpkg\")\n\n# Using the shorthand notation\nplaygrounds_close &lt;- playgrounds[publictransport,,op = st_is_within_distance, dist = 100]\n\n\n\n\n\n\n\n\n\nFigure¬†10.1: Note that the playgrounds within 100m of public transport (red dots) are a subset of all the playgrounds\n\n\n\n\n\n\n\nSpatial join Example (I)\n\nIn a spatial join, we want to add information from one dataset to another based on their spatial relationship\nFor example, we can add the name of the nearest public transport stop to each playground.\nFor this, we will use the function st_nearest_feature\nStrictly speaking, this function is not binary predicate, but is very useful for spatial joins\nTo make the example clearer, I will first discard all unnecessary columns from the datasets\n\n\npublictransport &lt;- publictransport[,\"CHSTNAME\"]\n\nplaygrounds &lt;- playgrounds[, \"name\"]\n\n\nplaygrounds_join &lt;- st_join(\n  playgrounds, \n  publictransport, \n  join = st_nearest_feature\n  )\n\n\nplaygrounds_join\n\nSimple feature collection with 184 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 2677632 ymin: 1242927 xmax: 2687639 ymax: 1253914\nProjected CRS: CH1903+ / LV95\n# A tibble: 184 √ó 3\n   name                                                    geom CHSTNAME        \n * &lt;chr&gt;                                            &lt;POINT [m]&gt; &lt;chr&gt;           \n 1 Buchenweg                                  (2685485 1245793) Z√ºrich, Burgwies\n 2 Buchlern Sportanlage                       (2678406 1248303) Z√ºrich, Friedho‚Ä¶\n 3 Mobile Spielanimation PAZMobile Spielanim‚Ä¶ (2682898 1244212) Z√ºrich, Rote Fa‚Ä¶\n 4 Alfred-Altherr-Terrasse                    (2684082 1249963) Z√ºrich, Langens‚Ä¶\n 5 Auf der Egg                                (2682672 1243867) Z√ºrich, Kalchb√º‚Ä¶\n 6 Belvoirpark                                (2682665 1245835) Z√ºrich, Brunaus‚Ä¶\n 7 Josefswiese                                (2681846 1248909) Z√ºrich, Schiffb‚Ä¶\n 8 Gertrudplatz                               (2681431 1247583) Z√ºrich, Locherg‚Ä¶\n 9 Wahlenpark                                 (2683172 1252246) Z√ºrich, Max-Bil‚Ä¶\n10 Rote Fabrik                                (2683004 1244150) Z√ºrich, Rote Fa‚Ä¶\n# ‚Ñπ 174 more rows\n\n\n\n\nSpatial join Example (II)\n\nIn the previous example, playgrounds_join has the same features as playgrounds, but with an additional column (CHSTNAME)\nThe reason for this, is that there is only one nearest station for every playground\nIn some joins, the number of rows in the joined dataset can be different from the original dataset\nFor example, if we want to join via the method within 100m, the result is different (see below).\nThis is because there can be multiple public transport stops within 100m of a playground\n\n\nplaygrounds_join2 &lt;- st_join(\n  playgrounds, \n  publictransport, \n  join = st_is_within_distance, \n  dist = 100\n  )\n\nnrow(playgrounds)\n## [1] 184\n\nnrow(playgrounds_join2)\n## [1] 186\n\nplaygrounds_join2\n## Simple feature collection with 186 features and 2 fields\n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: 2677632 ymin: 1242927 xmax: 2687639 ymax: 1253914\n## Projected CRS: CH1903+ / LV95\n## # A tibble: 186 √ó 3\n##    name                                                    geom CHSTNAME        \n##  * &lt;chr&gt;                                            &lt;POINT [m]&gt; &lt;chr&gt;           \n##  1 Buchenweg                                  (2685485 1245793) &lt;NA&gt;            \n##  2 Buchlern Sportanlage                       (2678406 1248303) &lt;NA&gt;            \n##  3 Mobile Spielanimation PAZMobile Spielanim‚Ä¶ (2682898 1244212) Z√ºrich, Rote Fa‚Ä¶\n##  4 Alfred-Altherr-Terrasse                    (2684082 1249963) &lt;NA&gt;            \n##  5 Auf der Egg                                (2682672 1243867) Z√ºrich, Kalchb√º‚Ä¶\n##  6 Belvoirpark                                (2682665 1245835) &lt;NA&gt;            \n##  7 Josefswiese                                (2681846 1248909) &lt;NA&gt;            \n##  8 Gertrudplatz                               (2681431 1247583) &lt;NA&gt;            \n##  9 Wahlenpark                                 (2683172 1252246) &lt;NA&gt;            \n## 10 Rote Fabrik                                (2683004 1244150) Z√ºrich, Rote Fa‚Ä¶\n## # ‚Ñπ 176 more rows\n\n\n\nSpatial join order\n\nNote that as is the case with all joins, the order of the datasets matters\nst_join by default is a left join (the first dataset is the left dataset)\nThe resulting dataset will have the geometry of the left dataset\nThis is especially noticeable when joining datasets of different types\n\n\nkreise &lt;- read_sf(\"data/week4-exercises/stadtkreise-zh.gpkg\")\n\nkreise &lt;- kreise[,\"STADTKREIS\"]\n\n\npublictransport_join &lt;- st_join(publictransport, kreise)\n\n\n\n\n\n\n\n\n\n\n\nif you reverse the order, each stadtkreis will be duplicated for every point in the publictransport dataset it intersects\n\n\nkreise_join &lt;- st_join(kreise, publictransport)\n\nnrow(kreise)\n## [1] 12\n\nnrow(kreise_join)\n## [1] 477\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Dataset kreise with 12 features\n\n\n\n\n\n\n\n\n\n\n\n(b) Dataset kreise_join with 477 features\n\n\n\n\n\n\n\nFigure¬†10.2: Note that all the duplicate stadtkreise overlap each other, so when you visualize the data, the issue is not noticeable",
    "crumbs": [
      "Week 4: Vector Advanced",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Topological relations</span>"
    ]
  },
  {
    "objectID": "week-4-topological-rel.html#custom-topological-relations",
    "href": "week-4-topological-rel.html#custom-topological-relations",
    "title": "Topological relations",
    "section": "Custom topological relations",
    "text": "Custom topological relations\n\nIn case the named topological relations (see Named topological relations (I)) do not covery a specific usecase, we can gain more fine grained control using so called DE-9IM strings.\nDE-9IM stands for Dimensionally Extended nine-Intersection Model and is the formal definition of the topological relations between two geometries\nDE-9IM powers all binary predicate functions like st_intersects etc.\nThe concept is a bit complex, but the idea is that it describes the topological relationship between two geometries in a 3x3 matrix.\nThe reasons the matrix is 3x3 is because it considers the intersection of the (1) interior, (2) boundary, and (3) exterior of the geometries.\nTable¬†10.1 shows how two overlapping polygons are analyzed using DE-9IM\n\n\n\n\n\nTable¬†10.1: Image source: M. W. Taves commons.wikimedia.org\n\n\n\n\n\n\n\n\n\n\nInterior\nBoundary\nExterior\n\n\n\n\nInterior\n\n\n\n\n\nBoundary\n\n\n\n\n\nExterior\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn the example in Table¬†10.1\n\nthe intersection of both interiors results in an area. This is denoted as 2\nthe intersection of interior with boundary results in a line, this is denoted as 1\nthe intersection of boundary with boundary results in two points, this is denoted as 0\n\nOnce all nine intersections have been regarded and encoded, the result is flattened into a string (with nine characters) which describes the topological relationship precisely\nIn the example in Table¬†10.1, a compact representation as string code is 212101212\nThis concept is especially interesting from the opposite perspective: i.e.¬†we describe the DE-9IM string we are looking for (see next chapter)\n\n\nRook‚Äôs case\n\nAs alluded in the last chapter, the DE-9IM string can help us look for specific relations not covered in the named topological relation\nConsider a chessboard like situation with 3x3 fields (see Figure¬†10.3)\nFrom the origin field, you might be interested to know all fields that share a full edge (i.e.¬†how a rook would move)\nThis relation is not covered by the named topological relations, so we need to model it using a DE-9IM string\n\n\n\n\n\n\n\n\n\nFigure¬†10.3: A 3x3 chessboard with a rook in the center field (origin). Which fields can the rook reach, if the constraint is that the destination field need to share an endge with the origin?\n\n\n\n\n\n\n\nModeling the rook‚Äôs case\n\nTo specify our requirement (destination field must share a boundary with the origin) we need to use the 3x3 DE-9IM we discussed in Table¬†10.1\nThe requirement is, that the interiors should not intersect (F) and the intersection of the boundaries should result in a line (1). All other intersections to not matter (*). This is displayed in Table¬†10.2\n\n\n\n\n\nTable¬†10.2: The DE-9IM for the rooks case. This can be flattend into the string F***1****\n\n\n\n\n\n\n\n\n\n\nInterior\nBoundary\nExterior\n\n\n\n\nInterior\nF\n*\n*\n\n\nBoundary\n*\n1\n*\n\n\nExterior\n*\n*\n*\n\n\n\n\n\n\n\n\n\n\n\n\nImplementation using st_relate\n\nWe can now use this string in the function st_realate to select fields where the condition is met\n\n\nst_relate(grid_orig,grid_dest, pattern = \"F***1****\")\n\nSparse geometry binary predicate list of length 1, where the predicate\nwas `relate_pattern'\n 1: 2, 4, 5, 7\n\n\nWe could also create our custom st_rook function and use this as we use other named predicates\n\nst_rook &lt;- \\(x, y) st_relate(x, y, pattern = \"F***1****\")\n\ngrid_rook &lt;- grid_dest[grid_orig, , op = st_rook]\n\n\n\n\n\n\n\n\n\nFigure¬†10.4: The chessboard situation with the potential fields for the rook highlighted with a red outline\n\n\n\n\n\n\n\n\n\nEgenhofer, Max, and John Herring. 1990. ‚ÄúA Mathematical Framework for the Definition of Topological Relations.‚Äù In Proc. The Fourth International Symposium on Spatial Data Handing, 803‚Äì13.",
    "crumbs": [
      "Week 4: Vector Advanced",
      "<span class='chapter-number'>10</span>¬† <span class='chapter-title'>Topological relations</span>"
    ]
  },
  {
    "objectID": "week-4-duckdb.html",
    "href": "week-4-duckdb.html",
    "title": "DuckDB",
    "section": "",
    "text": "DuckDB",
    "crumbs": [
      "Week 4: Vector Advanced",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>DuckDB</span>"
    ]
  },
  {
    "objectID": "week-4-duckdb.html#duckdb",
    "href": "week-4-duckdb.html#duckdb",
    "title": "DuckDB",
    "section": "",
    "text": "DuckDB is a relatively new, open-source, column-oriented relational database management system (RDBMS)\nIt is designed to provide high performance on complex queries against large databases in embedded configuration\nIt has a flexible extension mechanism consisting of core and community extensions\nspatial is a core extension\nDuckDB is a OLAP, in process RDBMS (see below)\n\n\n\nOLAP vs.¬†OLTP\n\nOLAP:\n\nRead-mostly workloads\nComplex queries\nread large parts of the data\nbulk appends / updates\n\nOLTP:\n\nMany samll writes and updates\nsimple queries\nread only individual rows\n\n\n\n\nIn process vs.¬†standalone\n\nDuckDB is an in process database management system, it is not an external process to which your application connects.\nIn other words: there is no client sending instructions nor a server to read and process them\nSQLite works the same way, while PostgreSQL, MySQL etc. do not\n\n\n\n\n\nTable¬†11.1: DuckDB fills a niche that no previous software has filled yet\n\n\n\n\n\n\n\n\n\n\nOLTP\nOLAP\n\n\n\n\nIn-Process\n\n\n\n\nStand-Alone",
    "crumbs": [
      "Week 4: Vector Advanced",
      "<span class='chapter-number'>11</span>¬† <span class='chapter-title'>DuckDB</span>"
    ]
  },
  {
    "objectID": "week-4-task.html",
    "href": "week-4-task.html",
    "title": "üöÄ Tasks",
    "section": "",
    "text": "Task 4.1\nFollow the instructions in Task 1.1 from Week 1 to create a new repo in the existing organization. As you did last week, solve the next task in a file named index.qmd.\n(a) King‚Äôs case (all fields)\n\n\n\n\n\n\n\n\n\n\n\n(b) Bishop‚Äôs case (diagonal fields)\n\n\n\n\n\n\n\nFigure¬†12.1: Different cases for chess piece movements. The King can move in all directions, the Bishop only on the diagonals",
    "crumbs": [
      "Week 4: Vector Advanced",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>üöÄ Tasks</span>"
    ]
  },
  {
    "objectID": "week-4-task.html#task-4.1",
    "href": "week-4-task.html#task-4.1",
    "title": "üöÄ Tasks",
    "section": "",
    "text": "Without consulting external help, try and specify the DE-9IM string for the queen and bishop‚Äôs case as shown in Figure¬†12.1. Note: concentrate on the boundary-boundary intersection. Note:\n\nNo intersection: F\nPoint intersection: 0\nLine intersetion: 1\nAny intersection: *",
    "crumbs": [
      "Week 4: Vector Advanced",
      "<span class='chapter-number'>12</span>¬† <span class='chapter-title'>üöÄ Tasks</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Dorman, Michael. 2023. ‚ÄúSpatial Data\nProgramming with Python ‚Äî Geobgu.xyz.‚Äù\nhttps://geobgu.xyz/py/.\n\n\nEgenhofer, Max, and John Herring. 1990. ‚ÄúA Mathematical Framework\nfor the Definition of Topological Relations.‚Äù In Proc. The\nFourth International Symposium on Spatial Data Handing, 803‚Äì13.\n\n\nHorn, Berthold KP. 1981. ‚ÄúHill Shading and the Reflectance\nMap.‚Äù Proceedings of the IEEE 69 (1): 14‚Äì47.\n\n\nLovelace, Robin, Jakub Nowosad, and Jannes Muenchow. 2019.\nGeocomputation with r. Chapman; Hall/CRC.\n\n\nPebesma, Edzer. 2018. ‚ÄúSimple Features for R:\nStandardized Support for Spatial Vector Data.‚Äù\nThe R Journal 10 (1): 439‚Äì46. https://doi.org/10.32614/RJ-2018-009.",
    "crumbs": [
      "References"
    ]
  }
]