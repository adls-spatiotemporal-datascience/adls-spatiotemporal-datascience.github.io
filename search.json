[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spatiotemporal Datascience",
    "section": "",
    "text": "Welcome\n\n\n\nImage Source\n\n\nThis course is taught in the Bachelor Degree Applied Digital Life Sciences at the Zurich University of Applied Sciences (ZHAW).\nIn this course, we will learn about methods and tools to analyze spatiotemporal data. We expect that you already have had some experience with spatial data and programming. To start the course, we will recap the following topic from the course GISc and Geodatabases: Geocomputation with R with raster and vector data\n\n\n\n\n\nTable¬†1: The course schedule (might be subject to change).\n\n\n\n\n\n\n\n\n\n\nSW\nCW\nDate\n\n\n\n\nVector Deepdive (Nils Ratnaweera)\n\n\nTutorial (in person)\n1\n8\n2026-02-17\n\n\nTask (async), due: 2026-03-02\n2\n9\n2026-02-24\n\n\nRaster Deepdive (Nils Ratnaweera)\n\n\nTutorial (in person)\n3\n10\n2026-03-03\n\n\nTask (async), due: 2026-03-16\n4\n11\n2026-03-10\n\n\nWeb Mapping (Nils Ratnaweera)\n\n\nTutorial (in person)\n5\n12\n2026-03-17\n\n\nInterpolation and Density Estimation (Patrick Laube)\n\n\nTheory (in person)\n6\n13\n2026-03-24\n\n\nTask (async), due: 2026-04-06\n7\n14\n2026-03-31\n\n\nNetwork Analysis (Patrick Laube)\n\n\nTheory (in person)\n8\n15\n2026-04-07\n\n\nTask (async), due: 2026-04-20\n9\n16\n2026-04-14\n\n\nMovement Analysis I (Patrick Laube)\n\n\nTheory (in person)\n10\n17\n2026-04-21\n\n\nTask (async), due: 2026-05-04\n11\n18\n2026-04-28\n\n\nMovement Analysis II (Patrick Laube)\n\n\nTheory (in person)\n12\n19\n2026-05-05\n\n\nTask (async), due: 2026-05-18\n13\n20\n2026-05-12\n\n\nOral Review (Nils Ratnaweera)\n\n\nIn Person\n14\n21\n2026-05-19",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "syllabus.html",
    "href": "syllabus.html",
    "title": "Syllabus",
    "section": "",
    "text": "Syllabus",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Syllabus</span>"
    ]
  },
  {
    "objectID": "syllabus.html#prerequisites",
    "href": "syllabus.html#prerequisites",
    "title": "Syllabus",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nCompletion of the course GISc and Geodatabases or equivalent experience with:\n\nR programming (tidyverse, basic data wrangling)\nVector data handling with sf\nRaster data handling with terra\n\nBasic familiarity with Git and GitHub\nFamiliarity with the command line",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Syllabus</span>"
    ]
  },
  {
    "objectID": "syllabus.html#assessment",
    "href": "syllabus.html#assessment",
    "title": "Syllabus",
    "section": "Assessment",
    "text": "Assessment\nThe assessment of the course is based to 100% via the so called course work, which are your solutions to the tasks provided throughout the course.\n\nWhat to Submit\nYou must submit solutions for all but one task assigned throughout the course ‚Äî you have one ‚Äújoker‚Äù that you may skip. Each submission will be checked for completeness (pass/fail). In addition, 2 tasks per student will be randomly selected for detailed grading using the criteria below.\nThe due dates are listed in Table¬†1.\n\n\nOral Review\nIn the final lesson, you will have the opportunity to present and discuss one of your solutions in a short individual conversation (~5‚Äì10 minutes). This is your chance to walk us through your approach, highlight what you learned, and reflect on your choices. This oral review will be graded pass / fail.\n\n\nGrading Criteria\nThe randomly selected tasks are evaluated on three dimensions:\n\n\n\n\n\n\n\n\nCriterion\nWeight\nDescription\n\n\n\n\nCorrectness\n40%\nCode runs without errors and produces the expected output\n\n\nDocumentation\n30%\nClear explanations of your approach, code is readable and commented where necessary\n\n\nReflection\n30%\nDiscussion of limitations, alternatives considered, or lessons learned\n\n\n\n\n\nUse of AI Tools\nYou may use AI assistants (ChatGPT, GitHub Copilot, Claude, etc.) to support your work. However:\n\nYour submission must reflect your understanding\nThe documentation and reflection sections are where you demonstrate this\n\nAs a general rule, the use of generative AI systems must be declared (based on der Z-RL-Guidelines AI in assessments, 01.04.2023).\n\nUse of generative AI systems in graded assignments Graded assignments are a type of assessment which, unlike examinations, are completed over a longer period of time that generally exceeds four hours. They mostly have an individual character in terms of the solutions provided and are not supervised. The use of generative AI systems for graded assignments reflects a natural and expected approach towards digital tools by students and continuing education participants and is an expression of their digital competence and modern working methods. However, to ensure that their personal contribution can be assessed, and in the interests of academic integrity, the use of generative AI systems must be made as transparent as possible. The share or extent of the contribution made by generative AI systems to the creative output generated by students and continuing education participants in compiling their graded assignments must be recognisable to third parties. In principle, there is therefore an obligation to declare all generative AI systems that influence a graded assignment in terms of its content. The Annex governs the aforementioned declaration obligation in detail. The provisions contained therein are subsidiary 1 in nature.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Syllabus</span>"
    ]
  },
  {
    "objectID": "syllabus.html#sec-gh-pages",
    "href": "syllabus.html#sec-gh-pages",
    "title": "Syllabus",
    "section": "Submission via GitHub Pages",
    "text": "Submission via GitHub Pages\nEach task is submitted as a rendered Quarto document hosted on GitHub Pages.\n\nInitial Setup\nOn GitHub:\n\nCreate a free organisation with a name of your choice and submit the URL to this organisation via email.\nYou need to do this only once, the rest of the steps are done for each task.\nIn this organisation, create a new, blank repository called vector-deepdive\n\nOn your local machine:\n\nInstall the CLI tool Quarto\nCreate a new directory for this week‚Äôs task\nInitialize a Git repository and link it to your GitHub repo:\ngit init\ngit remote add origin &lt;URL&gt;\nCreate _quarto.yml:\n\n\n_quarto.yml\n\nproject:\n  output-dir: _docs\n\nCreate index.qmd:\n\n\nindex.qmd\n\n# Solution for Vector Deepdive\n\nIn this document, I solve the tasks for *vector deepdive* of the course\n*Spatiotemporal Datascience*.\n\nPreview locally: quarto preview\nPublish: quarto publish gh-pages\n\n\n\nSubsequent Weeks\nFor each new task week, create a new repository in your organisation and follow the same workflow.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Syllabus</span>"
    ]
  },
  {
    "objectID": "syllabus.html#footnotes",
    "href": "syllabus.html#footnotes",
    "title": "Syllabus",
    "section": "",
    "text": "The provisions specified in the Annex thus serve as an ‚Äúalternative‚Äù if no others have been specified.‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Syllabus</span>"
    ]
  },
  {
    "objectID": "vector-deepdive-topological-rel.html",
    "href": "vector-deepdive-topological-rel.html",
    "title": "Topological relations",
    "section": "",
    "text": "Named topological relations",
    "crumbs": [
      "Vector Deepdive",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Topological relations</span>"
    ]
  },
  {
    "objectID": "vector-deepdive-topological-rel.html#named-topological-relations",
    "href": "vector-deepdive-topological-rel.html#named-topological-relations",
    "title": "Topological relations",
    "section": "",
    "text": "Topological relations describe the spatial relationships between objects.\nThey are also called binary topological relationships or binary predicates\nThey are logical statements (TRUE/FALSE) about the spatial relationships between two objects\nThe two objects are defined by ordered sets of points (typically forming points, lines and polygons) in two or more dimensions (Egenhofer and Herring 1990).\n\n\n\n\nUsage\n\nTopological relations can be used to subset or join spatial data\nFor example:\n\nSubsetting: Return all rivers that flow through the canton of Zurich\nJoining: For every train station, give me the name of the municipality it lies within\n\n\n\n\n\nNamed topological relations (I)\n\nThe most common topological relations are offered as functions / tools in most GIS software\nIn sf, there are a multitude of topological functions available:, st_intersects(), st_disjoint(), st_touches(), st_crosses()\nThese all work slightly differently, and are used in different contexts.\nFor example:\n\nst_covers() returns TRUE if no points of x are outside y, and at least one point of x is inside y.\nst_touches() returns TRUE if the geometries have at least one point in common, but their interiors do not intersect.\n\n\n\n\n\nKey predicates visualized\n\n\n\n\n\n\n\n\n\n\n\n(a) st_disjoint: no shared points\n\n\n\n\n\n\n\n\n\n\n\n(b) st_touches: shared boundary only\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c) st_intersects: any shared points (here with overlap)\n\n\n\n\n\n\n\n\n\n\n\n(d) st_contains: B entirely within A\n\n\n\n\n\n\n\nFigure¬†2.1: Key topological relations between two polygons (A in purple, B in green)\n\n\n\n\n\n\nNamed topological relations (II)\n\nSome of the relations mentioned above are symmetrical (the order of the geometries does not matter)\nFor example, if st_touches(x, y) is TRUE, then st_touches(y, x) is also TRUE\nOthers are not, meaning that the order of the geometries is important.\nFor example, st_contains(x, y) returns TRUE if x contains y, but st_contains(y, x) returns FALSE\nSome of the relations require additional arguments, such as st_is_within_distance(), which requires a distance argument\nYou can find the full list of topological relations in the sf documentation using ?geos_binary_pred\n\n\n\n\nst_contains vs st_covers vs st_within\n\nThese three are easily confused:\n\nst_contains(x, y): is y inside x, with at least one point of y in the interior of x?\nst_covers(x, y): is every point of y inside or on the boundary of x?\nst_within(x, y): the inverse of st_contains ‚Äî is x inside y?\n\nThe subtle difference between st_contains and st_covers: a point lying exactly on the boundary of a polygon is covered but not contained\n\n\npolygon &lt;- st_sfc(st_polygon(list(cbind(c(0,1,1,0,0), c(0,0,1,1,0)))))\npoint_inside &lt;- st_sfc(st_point(c(0.5, 0.5)))\npoint_on_boundary &lt;- st_sfc(st_point(c(0, 0.5)))\n\nst_contains(polygon, point_inside, sparse = FALSE)      # TRUE\n##      [,1]\n## [1,] TRUE\nst_contains(polygon, point_on_boundary, sparse = FALSE)  # FALSE\n##       [,1]\n## [1,] FALSE\nst_covers(polygon, point_on_boundary, sparse = FALSE)    # TRUE\n##      [,1]\n## [1,] TRUE\n\n\n\n\nPredicates vs.¬†operations\n\n\n\n\n\n\nImportantDon‚Äôt confuse predicates with operations!\n\n\n\n\nPredicate (e.g.¬†st_intersects): ‚ÄúDo these geometries intersect?‚Äù ‚Üí returns TRUE/FALSE\nOperation (e.g.¬†st_intersection): ‚ÄúGive me the geometry where they overlap‚Äù ‚Üí returns a new geometry\n\nThe same naming pattern applies to other pairs: st_difference (operation) has no corresponding predicate, while st_touches (predicate) has no corresponding operation.\n\n\n\n\n\nWhat do predicates return?\n\nCalling e.g.¬†st_intersects(x, y) does not return a simple TRUE/FALSE vector\nIt returns a sparse geometry binary predicate (sgbp) object ‚Äî essentially a list where each element contains the indices of y that match\n\n\na &lt;- rect_sfc(0, 0, 1, 1)          # one polygon\nb &lt;- c(\n  rect_sfc(0.5, 0, 1.5, 1),        # overlaps a\n  rect_sfc(2, 0, 3, 1)             # disjoint from a\n)\n\nst_intersects(a, b)\n## Sparse geometry binary predicate list of length 1, where the predicate\n## was `intersects'\n##  1: 1\n\n\nlengths() counts the number of matches per feature\nUse sparse = FALSE to get a dense logical matrix instead\n\n\nst_intersects(a, b, sparse = FALSE)\n##      [,1]  [,2]\n## [1,] TRUE FALSE\n\n\n\n\nSubset Examples\n\nLet‚Äôs take the example of playgrounds, public transport stops and Stadtkreise in Zurich\nWe can use topological predicates to subset one dataset based on another\n\n\nlibrary(sf)\nlibrary(readr)\n\n# source: https://www.stadt-zuerich.ch/geodaten/\nplaygrounds &lt;- read_sf(\"data/week4-exercises/playgrounds.gpkg\")\npublictransport &lt;- read_sf(\"data/week4-exercises/public_transport.gpkg\")\nkreise &lt;- read_sf(\"data/week4-exercises/stadtkreise-zh.gpkg\")\n\n\n\n\nSubset with st_intersects (default)\n\nThe default predicate is st_intersects ‚Äî this is the most common case\nFor example: which playgrounds lie within Stadtkreis 1?\n\n\nkreis1 &lt;- kreise[kreise$STADTKREIS == \"Kreis 1\", ]\n\nplaygrounds_k1 &lt;- playgrounds[kreis1, ]  # st_intersects is the default\n\nnrow(playgrounds_k1)\n## [1] 6\n\n\n\n\nSubset with a distance-based predicate\n\nWe can also use predicates that are not purely topological, such as st_is_within_distance\nFor example: which playgrounds are within 100m of a public transport stop?\n\n\n# Using the shorthand notation\nplaygrounds_close &lt;- playgrounds[publictransport,,op = st_is_within_distance, dist = 100]\n\nThe same can be written more readably with st_filter():\n\nplaygrounds_close &lt;- st_filter(playgrounds, publictransport, .predicate = st_is_within_distance, dist = 100)\n\n\n\n\n\n\n\n\n\n\nFigure¬†2.2: Note that the playgrounds within 100m of public transport (red dots) are a subset of all the playgrounds\n\n\n\n\n\n\n\n\nSpatial join Example (I)\n\nIn a spatial join, we want to add information from one dataset to another based on their spatial relationship\nFor example, we can add the name of the nearest public transport stop to each playground.\nFor this, we will use the function st_nearest_feature\nStrictly speaking, this function is not binary predicate, but is very useful for spatial joins\nTo make the example clearer, I will first discard all unnecessary columns from the datasets\n\n\n\npublictransport &lt;- publictransport[,\"CHSTNAME\"]\n\nplaygrounds &lt;- playgrounds[, \"name\"]\n\n\nplaygrounds_join &lt;- st_join(\n  playgrounds, \n  publictransport, \n  join = st_nearest_feature\n  )\n\n\n\nplaygrounds_join\n\nSimple feature collection with 184 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 2677632 ymin: 1242927 xmax: 2687639 ymax: 1253914\nProjected CRS: CH1903+ / LV95\n# A tibble: 184 √ó 3\n   name                                                    geom CHSTNAME        \n * &lt;chr&gt;                                            &lt;POINT [m]&gt; &lt;chr&gt;           \n 1 Buchenweg                                  (2685485 1245793) Z√ºrich, Burgwies\n 2 Buchlern Sportanlage                       (2678406 1248303) Z√ºrich, Friedho‚Ä¶\n 3 Mobile Spielanimation PAZMobile Spielanim‚Ä¶ (2682898 1244212) Z√ºrich, Rote Fa‚Ä¶\n 4 Alfred-Altherr-Terrasse                    (2684082 1249963) Z√ºrich, Langens‚Ä¶\n 5 Auf der Egg                                (2682672 1243867) Z√ºrich, Kalchb√º‚Ä¶\n 6 Belvoirpark                                (2682665 1245835) Z√ºrich, Brunaus‚Ä¶\n 7 Josefswiese                                (2681846 1248909) Z√ºrich, Schiffb‚Ä¶\n 8 Gertrudplatz                               (2681431 1247583) Z√ºrich, Locherg‚Ä¶\n 9 Wahlenpark                                 (2683172 1252246) Z√ºrich, Max-Bil‚Ä¶\n10 Rote Fabrik                                (2683004 1244150) Z√ºrich, Rote Fa‚Ä¶\n# ‚Ñπ 174 more rows\n\n\n\n\n\nSpatial join Example (II)\n\nIn the previous example, playgrounds_join has the same features as playgrounds, but with an additional column (CHSTNAME)\nThe reason for this, is that there is only one nearest station for every playground\nIn some joins, the number of rows in the joined dataset can be different from the original dataset\nFor example, if we want to join via the method within 100m, the result is different (see below).\nThis is because there can be none, or even multiple public transport stops within 100m of a playground\n\n\n\nplaygrounds_join2 &lt;- st_join(\n  playgrounds, \n  publictransport, \n  join = st_is_within_distance, \n  dist = 100\n  )\n\nnrow(playgrounds)\n## [1] 184\n\nnrow(playgrounds_join2)\n## [1] 186\n\n\n\nplaygrounds_join2\n\nSimple feature collection with 186 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 2677632 ymin: 1242927 xmax: 2687639 ymax: 1253914\nProjected CRS: CH1903+ / LV95\n# A tibble: 186 √ó 3\n   name                                                    geom CHSTNAME        \n * &lt;chr&gt;                                            &lt;POINT [m]&gt; &lt;chr&gt;           \n 1 Buchenweg                                  (2685485 1245793) &lt;NA&gt;            \n 2 Buchlern Sportanlage                       (2678406 1248303) &lt;NA&gt;            \n 3 Mobile Spielanimation PAZMobile Spielanim‚Ä¶ (2682898 1244212) Z√ºrich, Rote Fa‚Ä¶\n 4 Alfred-Altherr-Terrasse                    (2684082 1249963) &lt;NA&gt;            \n 5 Auf der Egg                                (2682672 1243867) Z√ºrich, Kalchb√º‚Ä¶\n 6 Belvoirpark                                (2682665 1245835) &lt;NA&gt;            \n 7 Josefswiese                                (2681846 1248909) &lt;NA&gt;            \n 8 Gertrudplatz                               (2681431 1247583) &lt;NA&gt;            \n 9 Wahlenpark                                 (2683172 1252246) &lt;NA&gt;            \n10 Rote Fabrik                                (2683004 1244150) Z√ºrich, Rote Fa‚Ä¶\n# ‚Ñπ 176 more rows\n\n\n\n\n\nSpatial join order\n\nNote that as is the case with all joins, the order of the datasets matters\nst_join by default is a left join (the first dataset is the left dataset)\nThe resulting dataset will have the geometry of the left dataset\nThis is especially noticeable when joining datasets of different types\n\n\n\nkreise &lt;- kreise[,\"STADTKREIS\"]\n\npublictransport_join &lt;- st_join(publictransport, kreise)\n\n\n\n\n\n\n\n\n\n\n\n\nif you reverse the order, each stadtkreis will be duplicated for every point in the publictransport dataset it intersects\n\n\nkreise_join &lt;- st_join(kreise, publictransport)\n\nnrow(kreise)\n## [1] 12\n\nnrow(kreise_join)\n## [1] 477\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Dataset kreise with 12 features\n\n\n\n\n\n\n\n\n\n\n\n(b) Dataset kreise_join with 477 features\n\n\n\n\n\n\n\nFigure¬†2.3: Note that all the duplicate stadtkreise overlap each other, so when you visualize the data, the issue is not noticeable",
    "crumbs": [
      "Vector Deepdive",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Topological relations</span>"
    ]
  },
  {
    "objectID": "vector-deepdive-topological-rel.html#custom-topological-relations",
    "href": "vector-deepdive-topological-rel.html#custom-topological-relations",
    "title": "Topological relations",
    "section": "Custom topological relations",
    "text": "Custom topological relations\n\nIn case the named topological relations (see Named topological relations (I)) do not covery a specific usecase, we can gain more fine grained control using so called DE-9IM strings.\nDE-9IM stands for Dimensionally Extended nine-Intersection Model and is the formal definition of the topological relations between two geometries\nDE-9IM powers all binary predicate functions like st_intersects etc.\nThe concept is a bit complex, but the idea is that it describes the topological relationship between two geometries in a 3x3 matrix.\nThe reasons the matrix is 3x3 is because it considers the intersection of the (1) interior, (2) boundary, and (3) exterior of the geometries.\nTable¬†2.1 shows how two overlapping polygons are analyzed using DE-9IM\n\n\n\n\n\n\nTable¬†2.1: Image source: M. W. Taves commons.wikimedia.org\n\n\n\n\n\n\n\n\n\n\nInterior\nBoundary\nExterior\n\n\n\n\nInterior\n\n\n\n\n\nBoundary\n\n\n\n\n\nExterior\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn the example in Table¬†2.1\n\nthe intersection of both interiors results in an area. This is denoted as 2\nthe intersection of interior with boundary results in a line, this is denoted as 1\nthe intersection of boundary with boundary results in two points, this is denoted as 0\n\nOnce all nine intersections have been regarded and encoded, the result is flattened into a string (with nine characters) which describes the topological relationship precisely\nIn the example in Table¬†2.1, a compact representation as string code is 212101212\nThis concept is especially interesting from the opposite perspective: i.e.¬†we describe the DE-9IM string we are looking for (see next chapter)\n\n\n\nNamed predicates are DE-9IM patterns\n\nEvery named predicate corresponds to one or more DE-9IM patterns\nFor example:\n\n\n\n\n\n\n\n\nPredicate\nDE-9IM pattern(s)\n\n\n\n\nst_intersects\nT********, *T*******, ***T*****, ****T**** (any non-empty intersection)\n\n\nst_touches\nFT*******, F**T*****, F***T****\n\n\nst_contains\nT*****FF*\n\n\nst_within\nT*F**F***\n\n\n\n\nNote how st_contains and st_within are mirror images of each other (swap rows and columns)\nThe wildcard * means ‚Äúany value‚Äù ‚Äî matching F, 0, 1, or 2\n\n\n\n\nRook‚Äôs case\n\nAs alluded in the last chapter, the DE-9IM string can help us look for specific relations not covered in the named topological relation\nConsider a chessboard like situation with 3x3 fields (see Figure¬†2.4)\nFrom the origin field, you might be interested to know all fields that share a full edge (i.e.¬†how a rook would move)\nThis relation is not covered by the named topological relations, so we need to model it using a DE-9IM string\n\n\n\n\n\n\n\n\n\nFigure¬†2.4: A 3x3 chessboard with a rook in the center field (origin). Which fields can the rook reach, if the constraint is that the destination field need to share an endge with the origin?\n\n\n\n\n\n\n\n\nModeling the rook‚Äôs case\n\nTo specify our requirement (destination field must share a boundary with the origin) we need to use the 3x3 DE-9IM we discussed in Table¬†2.1\nThe requirement is, that the interiors should not intersect (F) and the intersection of the boundaries should result in a line (1). All other intersections to not matter (*). This is displayed in Table¬†2.2\n\n\n\n\n\nTable¬†2.2: The DE-9IM for the rooks case. This can be flattend into the string F***1****\n\n\n\n\n\n\n\n\n\n\nInterior\nBoundary\nExterior\n\n\n\n\nInterior\nF\n*\n*\n\n\nBoundary\n*\n1\n*\n\n\nExterior\n*\n*\n*\n\n\n\n\n\n\n\n\n\n\n\n\n\nExploring with st_relate\n\nWithout a pattern argument, st_relate returns the actual DE-9IM string for each pair of geometries\nThis is useful for exploration: you can inspect the strings and then decide which pattern to match\n\n\nst_relate(grid_orig, grid_dest)\n\n     [,1]        [,2]        [,3]        [,4]        [,5]        [,6]       \n[1,] \"FF2F01212\" \"FF2F11212\" \"FF2F01212\" \"FF2F11212\" \"FF2F11212\" \"FF2F01212\"\n     [,7]        [,8]       \n[1,] \"FF2F11212\" \"FF2F01212\"\n\n\n\n\n\nMatching with st_relate\n\nOnce we know the pattern we are looking for, we can pass it as the pattern argument\nst_relate then returns a logical (TRUE/FALSE) sparse matrix, just like the named predicates\n\n\nst_relate(grid_orig, grid_dest, pattern = \"F***1****\")\n\nSparse geometry binary predicate list of length 1, where the predicate\nwas `relate_pattern'\n 1: 2, 4, 5, 7\n\n\n\nWe could also create our custom st_rook function and use this as we use other named predicates\n\nst_rook &lt;- \\(x, y) st_relate(x, y, pattern = \"F***1****\")\n\ngrid_rook &lt;- grid_dest[grid_orig, , op = st_rook] |&gt; \n  st_sample(1000, type = \"hexagonal\",by_polygon = TRUE)\n\n\n\n\n\n\n\n\n\nFigure¬†2.5: The chessboard situation with the potential fields for the rook highlighted with a red outline",
    "crumbs": [
      "Vector Deepdive",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Topological relations</span>"
    ]
  },
  {
    "objectID": "vector-deepdive-topological-rel.html#references",
    "href": "vector-deepdive-topological-rel.html#references",
    "title": "Topological relations",
    "section": "References",
    "text": "References\n\n\n\n\nEgenhofer, Max, and John Herring. 1990. ‚ÄúA Mathematical Framework for the Definition of Topological Relations.‚Äù Proc. The Fourth International Symposium on Spatial Data Handing, 803‚Äì13.",
    "crumbs": [
      "Vector Deepdive",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Topological relations</span>"
    ]
  },
  {
    "objectID": "vector-deepdive-duckdb.html",
    "href": "vector-deepdive-duckdb.html",
    "title": "DuckDB",
    "section": "",
    "text": "Why DuckDB for spatial data?",
    "crumbs": [
      "Vector Deepdive",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>DuckDB</span>"
    ]
  },
  {
    "objectID": "vector-deepdive-duckdb.html#olap-vs.-oltp",
    "href": "vector-deepdive-duckdb.html#olap-vs.-oltp",
    "title": "DuckDB",
    "section": "OLAP vs.¬†OLTP",
    "text": "OLAP vs.¬†OLTP\n\nOLAP (Online Analytical Processing)\n\nRead-mostly workloads\nComplex queries\nread large parts of the data\nbulk appends / updates\n\nOLTP (Online Transaction Processing)\n\nMany small writes and updates\nsimple queries\nread only individual rows",
    "crumbs": [
      "Vector Deepdive",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>DuckDB</span>"
    ]
  },
  {
    "objectID": "vector-deepdive-duckdb.html#in-process-vs.-standalone",
    "href": "vector-deepdive-duckdb.html#in-process-vs.-standalone",
    "title": "DuckDB",
    "section": "In process vs.¬†standalone",
    "text": "In process vs.¬†standalone\n\nDuckDB is an in process database management system, it is not an external process to which your application connects.\nIn other words: there is no client sending instructions nor a server to read and process them\nSQLite works the same way, while PostgreSQL, MySQL etc. do not\n\n\n\n\n\nTable¬†3.1: DuckDB fills a niche that no previous software has filled yet\n\n\n\n\n\n\n\n\n\n\nOLTP\nOLAP\n\n\n\n\nIn-Process\n\n\n\n\nStand-Alone",
    "crumbs": [
      "Vector Deepdive",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>DuckDB</span>"
    ]
  },
  {
    "objectID": "vector-deepdive-duckdb.html#sec-duckdb-practice",
    "href": "vector-deepdive-duckdb.html#sec-duckdb-practice",
    "title": "DuckDB",
    "section": "Duckdb in practice",
    "text": "Duckdb in practice\n\nDownload wald-kantone.duckdb from moodle (forest + canton boundaries)\nInstall the duckdb CLI and duckdb R package\nInstall the dbeaver Community Version\nUsing dbeaver, connect to the duckdb database\nInstall and load the spatial extension:\n\nINSTALL spatial;\nLOAD spatial;\n\n\nVerify both tables are present and explore them:\n\nSHOW TABLES;\nSELECT * FROM wald;\nSELECT * FROM kantone;\n\nCreate an R-Tree spatial index for both tables:\n\nCREATE INDEX kantone_idx ON kantone USING RTREE (geom);\nCREATE INDEX wald_idx ON wald USING RTREE (geom);\n\n\nWhy spatial indices?\n\nWithout an index, a spatial query like WHERE st_intersects(a, b) must check every pair of geometries ‚Äî this is very slow on large datasets\nAn R-Tree index organizes geometries by their bounding boxes in a tree structure\nWhen querying, the R-Tree quickly eliminates geometries whose bounding boxes don‚Äôt overlap ‚Äî only the remaining candidates are checked with the exact (expensive) geometry test\nThis reduces the number of comparisons dramatically (e.g.¬†from millions to thousands)\nR-Trees are the standard spatial index in most databases (PostGIS, SpatiaLite, DuckDB) and also power sf‚Äôs spatial predicates internally\n\n\n\n\nSQL VIEW\n\nA VIEW is a named SQL query ‚Äî it acts like a virtual table\nEvery time you access a VIEW, the underlying query is re-executed\nThis lets us build complex analyses step-by-step (rather than nesting queries)\n\n\nUnlike materialized tables, VIEWs don‚Äôt store data on disk. This means they don‚Äôt take up extra space and always reflect the current state of the source data. The trade-off is that they are re-computed on every access. We will use VIEWs to recreate the forest-per-canton analysis from Task 1 in SQL.\n\n\nOur first VIEW: a subset of the forest dataset (for faster iteration)\n\n\n\nLimit to 1‚Äô000 rows and store as a VIEW:\n\n1CREATE VIEW wald2 AS\n2SELECT * FROM wald LIMIT 1000;\n\n1\n\nPrepend CREATE VIEW name AS to any SELECT‚Ä¶\n\n2\n\n‚Ä¶ to store it as a reusable virtual table\n\n\n\nQuery it like a regular table:\n\nSELECT * FROM wald2;\n\n\n\nDevelop SQL Code\n\nIntersect forest polygons with canton boundaries:\n\nSELECT \n  name, \n2  st_intersection(w.geom, k.geom),\n1FROM wald2 w, kantone k;\n\n1\n\nw and k are aliases‚Ä¶\n\n2\n\n‚Ä¶ used in the intersection\n\n\n\n\nProblem: this computes a cross join ‚Äî every forest polygon x every canton (1‚Äô000 x 26 = 26‚Äô000 pairs)\nSolution: add a WHERE clause to filter early:\n\nSELECT\n  name,\n  st_intersection(w.geom, k.geom),\nFROM wald2 w, kantone k\n1WHERE st_intersects(w.geom, k.geom);\n\n1\n\nOnly compute the intersection for pairs that actually overlap\n\n\n\nThis is where the R-Tree index pays off ‚Äî DuckDB discards non-overlapping pairs without checking every combination\n\n\n\n\n\n\n\nNotest_intersects vs st_intersection\n\n\n\nNote how this query uses both: st_intersects in the WHERE clause is a predicate (returns true/false to filter rows), while st_intersection in the SELECT clause is a geometric operation (computes the overlapping geometry). Same pattern as in R/sf!\n\n\n\n\n\nInspecting query plans with EXPLAIN\n\nYou can prepend EXPLAIN to any query to see how DuckDB will execute it, without actually running it\nTry comparing the two versions in dbeaver:\n\n-- Without WHERE: cross join of all pairs\nEXPLAIN SELECT name, st_intersection(w.geom, k.geom)\nFROM wald2 w, kantone k;\n\n-- With WHERE: only matching pairs (uses R-Tree index)\nEXPLAIN SELECT name, st_intersection(w.geom, k.geom)\nFROM wald2 w, kantone k\nWHERE st_intersects(w.geom, k.geom);\n\nIn the second plan, look for an INDEX SCAN or INDEX JOIN ‚Äî this confirms the R-Tree is being used\n\n\n\nWe need the area of each intersection, not the geometry itself:\n\nSELECT \n  name, \n1  st_area(st_intersection(w.geom, k.geom)) as wald_area,\nFROM wald2 w, kantone k\nWHERE st_intersects(w.geom, k.geom);\n\n1\n\nst_area calculates the area of the intersection\n\n\n\n\nSave this as a VIEW before aggregating:\n\n1CREATE VIEW wald_kantone AS\nSELECT \n  name, \n  st_area(st_intersection(w.geom, k.geom)) AS wald_area,\nFROM wald2 w, kantone k\nWHERE st_intersects(w.geom, k.geom);\n\n1\n\nThis creates a VIEW from the preceding query\n\n\n\n\nQuery the VIEW like a table, then aggregate with GROUP BY:\n\nSELECT \n3  name,\n2  sum(wald_area) as wald_area\nFROM wald_kantone\n1GROUP BY name;\n\n1\n\nIf we use GROUP BY in a SQL query..\n\n2\n\n‚Ä¶ we need to wrap all columns with aggregate function‚Ä¶\n\n3\n\n‚Ä¶ except for the columns that we use for grouping\n\n\n\n\nSave the aggregation as a VIEW:\n\nCREATE VIEW wald_kanton_grp AS\nSELECT \n  name, \n  sum(wald_area) as wald_area\nFROM wald_kantone\nGROUP BY name;\n\n\nJoin with kantone to get the total canton area and compute the fraction:\n\nSELECT \n3    kantone.name,\n4    wald_area/area as waldanteil,\nFROM wald_kanton_grp \n1LEFT JOIN kantone\n2ON wald_kanton_grp.name=kantone.name;\n\n1\n\nLEFT JOIN appends columns from another table‚Ä¶\n\n2\n\n‚Ä¶ matched by the ON condition\n\n3\n\nWe only need the canton name‚Ä¶\n\n4\n\n‚Ä¶ and the fraction wald_area / area\n\n\n\n\nSave as a final VIEW, ordered by forest share:\n\nCREATE VIEW kanton_frac AS\nSELECT \n    kantone.name,                 \n    wald_area/area as waldanteil, \nFROM wald_kanton_grp \nLEFT JOIN kantone \nON wald_kanton_grp.name=kantone.name\n1ORDER BY waldanteil DESC;\n\n1\n\nWe can ORDER BY to show us the highest values first\n\n\n\n\n\nScaling up: from subset to full dataset\n\nSo far we only used 1‚Äô000 forest features ‚Äî results are incomplete\nSince we used VIEWs, switching to the full dataset is trivial:\n\nCREATE OR REPLACE VIEW wald2 AS\nSELECT * FROM wald;\n\nNow every downstream VIEW automatically uses the full data:\n\nSELECT * FROM kanton_frac;\n\nCREATE OR REPLACE VIEW is needed because wald2 already exists. This is the key advantage of VIEWs: by replacing just one definition, the entire chain of dependent queries updates automatically. The downside is that the full query now takes longer since nothing is materialized.\n\n\n\n\nVIEW vs CREATE TABLE ... AS\n\nA VIEW is lazy ‚Äî the query is re-executed every time you access it\nIf performance matters, you can materialize intermediate results using CREATE TABLE ... AS:\n\n1CREATE TABLE wald_kantone_mat AS\nSELECT\n  name,\n  st_area(st_intersection(w.geom, k.geom)) AS wald_area\nFROM wald2 w, kantone k\nWHERE st_intersects(w.geom, k.geom);\n\n1\n\nThis stores the result as an actual table on disk\n\n\n\nTrade-off: materialized tables are faster to query, but they take up disk space and do not update automatically when the source data changes\nVIEWs are the opposite: no extra storage, always up-to-date, but slower to query",
    "crumbs": [
      "Vector Deepdive",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>DuckDB</span>"
    ]
  },
  {
    "objectID": "vector-deepdive-duckdb.html#import-results-into-r",
    "href": "vector-deepdive-duckdb.html#import-results-into-r",
    "title": "DuckDB",
    "section": "Import results into R",
    "text": "Import results into R\n\nConnect from R, load the spatial extension, and read the VIEW:\n\n\nlibrary(duckdb)\n\ncon &lt;- dbConnect(\n  duckdb(),\n  dbdir = \"data/week4-exercises/wald-kantone.duckdb\",\n  read_only = TRUE\n)\n\ndbExecute(con, \"LOAD spatial;\")\nkanton_frac &lt;- dbReadTable(con, \"kanton_frac\")\n\ndbDisconnect(con)",
    "crumbs": [
      "Vector Deepdive",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>DuckDB</span>"
    ]
  },
  {
    "objectID": "vector-deepdive-task.html",
    "href": "vector-deepdive-task.html",
    "title": "üöÄ Tasks",
    "section": "",
    "text": "Task 1\nFollow the instructions in Submission via GitHub Pages to create a new repo in the existing organization. Solve the tasks in a file named index.qmd.\nDownload the datasets swissTLM3D and swissboundaries3d from swisstopo. Using swissTLM3d and swissboundaries3d, calculate the percentage of area covered by forest per canton. Visualize the results (in a map and / or a plot).\nRender the document using quarto preview. Publish your result using quarto publish gh-pages",
    "crumbs": [
      "Vector Deepdive",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>üöÄ Tasks</span>"
    ]
  },
  {
    "objectID": "vector-deepdive-task.html#task-3",
    "href": "vector-deepdive-task.html#task-3",
    "title": "üöÄ Tasks",
    "section": "Task 3",
    "text": "Task 3\nWithout consulting external help, try and specify the DE-9IM string for the queen and bishop‚Äôs case as shown in Figure¬†5.1.\nConcentrate on the boundary-boundary intersection. Note:\n\nNo intersection: F\nPoint intersection: 0\nLine intersetion: 1\nAny intersection: *\n\nThe 3x3 ‚Äúchessboard‚Äù is available on moodle.\n\n\n\n\n\n\n\n\n\n\n\n\n(a) King‚Äôs case (all fields)\n\n\n\n\n\n\n\n\n\n\n\n(b) Bishop‚Äôs case (diagonal fields)\n\n\n\n\n\n\n\nFigure¬†5.1: Different cases for chess piece movements. The King can move in all directions, the Bishop only on the diagonals",
    "crumbs": [
      "Vector Deepdive",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>üöÄ Tasks</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Egenhofer, Max, and John Herring. 1990. ‚ÄúA Mathematical Framework\nfor the Definition of Topological Relations.‚Äù Proc. The\nFourth International Symposium on Spatial Data Handing, 803‚Äì13.",
    "crumbs": [
      "References"
    ]
  }
]