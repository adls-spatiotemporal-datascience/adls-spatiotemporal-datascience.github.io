[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spatiotemporal Datascience",
    "section": "",
    "text": "Welcome to the course Spatiotemporal Datascience\n\n\n\nImage Source\n\n\nThis course is taught in the Bachelor Degree Applied Digital Life Sciences at the Zurich University of Applied Sciences (ZHAW).\nIn this course, we will learn about methods and tools to analyze spatiotemporal data. We expect that you already have had some experience with spatial data and programming. To start the course, we will recap the following topic from the course GISc and Geodatabases: Geocomputation with R with raster and vector data\n\nOur preliminary schedule is as follows. Please note that this schedule is subject to change!\n\n\n\n\n\n\n\n\n#\nCW\nDate\nLesson\nLecturer\n\n\n\n\n1\n8\n18.02.25\nModule introduction / Vector Data (recap)\nrata\n\n\n2\n9\n25.02.25\nGeoPython Confence\nrata\n\n\n3\n10\n04.03.25\nRaster Data (recap)\nrata\n\n\n4\n11\n11.03.25\nVector Advanced\nrata\n\n\n5\n12\n18.03.25\nRaster Advanced\nrata\n\n\n6\n13\n25.03.25\ntba\ntba\n\n\n7\n14\n01.04.25\nInterpolation\nlaup\n\n\n8\n15\n08.04.25\ntba\ntba\n\n\n9\n16\n15.04.25\nNetwork Analysis I: Centrality\nlaup\n\n\n10\n17\n22.04.25\nNetwork Analysis II: Shortest Path / TSP\nlaup\n\n\n11\n18\n29.04.25\nProject Week (no class)\nrata\n\n\n12\n19\n06.05.25\nMovement Analysis I: Patterns\nlaup\n\n\n13\n20\n13.05.25\nMovement Analysis II: Context\nlaup\n\n\n14\n21\n20.05.25\ntba\ntba\n\n\n15\n22\n27.05.25\ntba\ntba",
    "crumbs": [
      "Welcome to the course *Spatiotemporal Datascience*"
    ]
  },
  {
    "objectID": "week-1-simple-features.html",
    "href": "week-1-simple-features.html",
    "title": "Simple Features",
    "section": "",
    "text": "Simple feature standard",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "week-1-simple-features.html#simple-feature-standard",
    "href": "week-1-simple-features.html#simple-feature-standard",
    "title": "Simple Features",
    "section": "",
    "text": "Simple features is an open standard (ISO 19125-1:2004) developed and endorsed by the Open Geospatial Consortium (OGC)\nThe standard is widely implemented in spatial databases (such as PostGIS), desktop GIS (such as ArcGIS, QGIS) and scripting languages (such as R, Python)\n\n\nThis is the secret message for Area 2",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "week-1-simple-features.html#what-is-a-feature",
    "href": "week-1-simple-features.html#what-is-a-feature",
    "title": "Simple Features",
    "section": "What is a feature?",
    "text": "What is a feature?\nThe standard says:\n\nA simple feature is defined […] to have both spatial and non-spatial attributes. Spatial attributes are geometry valued, and simple features are based on 2D geometry with linear interpolation between vertices.\n\n\nA feature is thought of as a thing / an object in the real world, such as a building or a tree.\nFeatures have:\n\na geometry describing where on Earth the feature is located\nattributes, which describe other properties.\n\nFor example:\n\nThe geometry of a tree can be the delineation of its crown, of its stem, or the point indicating its center\nattributes (properties) may include its height, color, diameter at breast height at a particular date, and so on",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "week-1-simple-features.html#simple-feature-model",
    "href": "week-1-simple-features.html#simple-feature-model",
    "title": "Simple Features",
    "section": "Simple Feature Model",
    "text": "Simple Feature Model\n\nSimple features is a hierarchical data model that represents a wide range of geometry types.\nAll geometries are composed of points in a 2-, 3- or 4-dimensional space\nOf 18 geometry types supported by the specification, only the following seven (see Figure 1.1 and Table 1.1) are used in the vast majority of geographic research:\n\nThree basic types: points, linestrings, polygons\nThree composite types: mutlipoints, multilinestrings, multipolygons\nOne special case: geometrycollection (which can be a conglomarate of all the afore mentioned)\n\nThese seven core geometry types are fully supported by the R package sf (Pebesma 2018)\n\n\n\n\n\n\n\nFigure 1.1: Image source: Dorman (2023)\n\n\n\n\n\n\n\nTable 1.1: Source: Pebesma (2018)\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n# of Dimension\n\n\n\n\nPOINT\nzero-dimensional geometry containing a single point\n0\n\n\nLINESTRING\nsequence of points connected by straight1 line pieces\n1\n\n\nPOLYGON\nsequence of points form a closed2 ring3\n2\n\n\nMULTIPOINT\nset of points\n0\n\n\nMULTILINESTRING\nset of linestrings\n1\n\n\nMULTIPOLYGON\nset of polygons\n2\n\n\nGEOMETRYCOLLECTION\nset of geometries of any of the above types\nNA",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "week-1-simple-features.html#simple-features-in-r",
    "href": "week-1-simple-features.html#simple-features-in-r",
    "title": "Simple Features",
    "section": "Simple features in R",
    "text": "Simple features in R\nSimple Features in R is modelled in three levels:\n\nSimple feature geometries (sfg): Individual Simple Feature objects\nSimple Feature geometry columns (sfc): A list column of sfgs\nSimple Features (with attributes): A sfc with attributes, i.e. additional columns",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "week-1-simple-features.html#sfg-simple-feature-geometry",
    "href": "week-1-simple-features.html#sfg-simple-feature-geometry",
    "title": "Simple Features",
    "section": "sfg: simple feature geometry",
    "text": "sfg: simple feature geometry\nSimple feature geometries are implemented as R native data, using the following rules:\n\na single POINT is a numeric vector\na set of points, e.g. in a LINESTRING or ring of a POLYGON is a matrix, each row containing a point\nany other set is a list\n\nLet’s create some simple feature geometries by hand: However, creator functions are rarely used in practice, since we typically bulk read and write spatial data. They are useful for illustration purposes.\n\nPoints\n\nlibrary(sf)\nfracht &lt;- st_point(c(2685374, 1256519))\n\nfracht\n\n\nplot(fracht)\n\n\n\n\n\n\n\n\n\n\nLinestrings\n\ncoords &lt;- c(\n  2684336, 1255553, \n  2682705, 1258929\n  ) |&gt; \n  matrix(ncol = 2, byrow = TRUE)\n\ncoords\n\n        [,1]    [,2]\n[1,] 2684336 1255553\n[2,] 2682705 1258929\n\n\n\npiste &lt;- st_linestring(coords)\n\npiste\n\n\nplot(piste)\n\n\n\n\n\n\n\n\n\n\nPolygons\n\ncoords_2 &lt;- c(\n  2684142, 1255702, # ↰ \n  2685600, 1256958, # start and end must\n  2682534, 1259699, # be identical (closed)\n  2684142, 1255702  # ↲ \n) |&gt; \n  matrix(ncol = 2, byrow = TRUE) |&gt; \n  list()\n\ncoords_2\n\n[[1]]\n        [,1]    [,2]\n[1,] 2684142 1255702\n[2,] 2685600 1256958\n[3,] 2682534 1259699\n[4,] 2684142 1255702\n\n\n\nflughafen &lt;- st_polygon(coords_2)\n\nflughafen\n\n\nBefore we said that the ring of a polygon is a matrix. Now we are turning it into a list. This is because a polygon could contain holes, which are additional rings.\n\n\nplot(flughafen)",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "week-1-simple-features.html#sfc-simple-feature-geometry-columns",
    "href": "week-1-simple-features.html#sfc-simple-feature-geometry-columns",
    "title": "Simple Features",
    "section": "sfc: Simple feature geometry columns",
    "text": "sfc: Simple feature geometry columns\n\nAs you might have noticed, we didn’t specify a CRS when creating the sfg objects. This is because we weren’t able to.\nIf we convert the sfg to sfc, we can (and should) specify a crs.\n(Usually, a sfc contains more than one sfg. This is not mandatory, and for convenience we will just use a single sfg to showcase sfc)\n\n\nfracht_sfc &lt;- st_sfc(fracht, crs = 2056)\n\nfracht_sfc\n\nGeometry set for 1 feature \nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 2685374 ymin: 1256519 xmax: 2685374 ymax: 1256519\nProjected CRS: CH1903+ / LV95\n\n\n\n\npiste_sfc &lt;- st_sfc(piste, crs = 2056)\n\npiste_sfc\n\nGeometry set for 1 feature \nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 2682705 ymin: 1255553 xmax: 2684336 ymax: 1258929\nProjected CRS: CH1903+ / LV95\n\n\n\n\nflughafen_sfc &lt;- st_sfc(flughafen, crs = 2056)\n\nflughafen_sfc\n\nGeometry set for 1 feature \nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2682534 ymin: 1255702 xmax: 2685600 ymax: 1259699\nProjected CRS: CH1903+ / LV95",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "week-1-simple-features.html#sf-simple-features",
    "href": "week-1-simple-features.html#sf-simple-features",
    "title": "Simple Features",
    "section": "sf: Simple features",
    "text": "sf: Simple features\n\nSimple features have attributes\nIn order to add attributes to a simple feature column (sfc), we need to convert it to a simple feature (sf)\n\n\nfracht_sf &lt;- st_sf(fracht_sfc)\n\nfracht_sf$name &lt;- \"Ost\"\n\n\nA sf class is a subset (i.e. special case) of the class data.frame.\nMost things which can be done with a data.frame, can be done with an sf object as well\nMany tidyverse functions are implemented to nicely work with sf\n\n\n# sf objects are also dataframes\nis.data.frame(fracht_sf)\n\n[1] TRUE\n\n\n\n\nNote: Geometries are sticky. This means they aren’t dropped implicitly\n\n\n# Geometries are sticky\nfracht_sf[, \"name\"] \n\nSimple feature collection with 1 feature and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 2685374 ymin: 1256519 xmax: 2685374 ymax: 1256519\nProjected CRS: CH1903+ / LV95\n  name              fracht_sfc\n1  Ost POINT (2685374 1256519)\n\n\n\n\npiste_sf &lt;- st_sf(piste_sfc)\n\npiste_sf$nr &lt;- 34\n\nflughafen_sf &lt;- st_sf(flughafen_sfc)\n\nflughafen_sf$name &lt;- \"Flughafen Zürich\"\n\nflughafen_sf\n\nSimple feature collection with 1 feature and 1 field\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2682534 ymin: 1255702 xmax: 2685600 ymax: 1259699\nProjected CRS: CH1903+ / LV95\n                   flughafen_sfc             name\n1 POLYGON ((2684142 1255702, ... Flughafen Zürich",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "week-1-simple-features.html#sec-plotting",
    "href": "week-1-simple-features.html#sec-plotting",
    "title": "Simple Features",
    "section": "Plotting simple features",
    "text": "Plotting simple features\n\nVarious libraries support plotting sf objects:\n\nbase R (sf provides a plot-method)\nGeneral purpose libraries such as ggplot2\nDedicated geospatial plotting libraries such as tmap\n\nUse:\n\nbase R: If you want to take a quick look at your data. Base R has the most compact syntax and is extremely fast in plotting\nggplot2: If you only have (small-ish) vector data (no raster) and/or want to leverage the power of ggplot2\ntmap: If you want to use all features a dedicated library for geospatial data has to offer: North arrow, scale bar, interactive (web) maps\n\n\n#\n# Using base R\nplot(st_geometry(flughafen_sf))\nplot(piste_sf, add = TRUE)\nplot(fracht_sf, add = TRUE)\n#\n# Using ggplot2\nlibrary(ggplot2)\nggplot() +\n  geom_sf(data = flughafen_sf) +\n  geom_sf(data = piste_sf) +\n  geom_sf(data = fracht_sf)\n#\n# Using tmap\nlibrary(tmap)\ntm_shape(flughafen_sf) + tm_polygons() +\n  tm_shape(piste_sf) + tm_lines() +\n  tm_shape(fracht_sf) + tm_dots()\n\n\n\n\n\n\nbase R\n\n\n\n\n\n\n\nlibrary ggplot2\n\n\n\n\n\n\n\nlibrary tmap",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "week-1-simple-features.html#sec-plotting-interactive",
    "href": "week-1-simple-features.html#sec-plotting-interactive",
    "title": "Simple Features",
    "section": "Interactive maps",
    "text": "Interactive maps\nThe tmap library can render the map either in a static plot as above (the default) or as an interactive web map (see below)\n\n# set tmap_mode to \"view\" for an interactive web map\ntmap_mode(\"view\")\n\ntm_shape(flughafen_sf) + tm_polygons() +\n  tm_shape(piste_sf) + tm_lines() +\n  tm_shape(fracht_sf) + tm_dots()",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "week-1-simple-features.html#exercises",
    "href": "week-1-simple-features.html#exercises",
    "title": "Simple Features",
    "section": "Exercises",
    "text": "Exercises\n\nCreate some simple feature geometries (sfg) of objects you know “by hand”\n\n\nCreate at least one POINT, one LINESTRING and one POLYGON geometry\nYou can capture the coordinates of the nodes from map.geo.admin if these are is Switzerland and openstreetmap (or similar) if they aren’t\n\n\nCreate simple feature columns from you sfgs. Make sure that you assign the correct CRS\nCreate simple features (sf) from your sfcs and add some attributes\n\n\n\n\n\nDorman, Michael. 2023. “Spatial Data Programming with Python — Geobgu.xyz.” https://geobgu.xyz/py/.\n\n\nPebesma, Edzer. 2018. “Simple Features for R: Standardized Support for Spatial Vector Data.” The R Journal 10 (1): 439–46. https://doi.org/10.32614/RJ-2018-009.",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "week-1-simple-features.html#footnotes",
    "href": "week-1-simple-features.html#footnotes",
    "title": "Simple Features",
    "section": "",
    "text": "non-selfintersecting↩︎\nnon-selfintersecting↩︎\nthe first ring denotes the exterior ring, zero or more subsequent rings denote holes in this exterior ring↩︎",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "week-1-vector-io.html",
    "href": "week-1-vector-io.html",
    "title": "Vector data I/O",
    "section": "",
    "text": "GDAL / ogr2ogr\nGDAL:",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Vector data I/O</span>"
    ]
  },
  {
    "objectID": "week-1-vector-io.html#sec-gdal-ogr2ogr",
    "href": "week-1-vector-io.html#sec-gdal-ogr2ogr",
    "title": "Vector data I/O",
    "section": "",
    "text": "is an open source translator library for raster and vector geospatial data formats.\nstands for Geospatial Data Abstraction Library\nis used in most geospatial software, be it FOSS or proprietary. The list includes: ArcGIS, QGIS, R (sf) and Python (geopandas)",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Vector data I/O</span>"
    ]
  },
  {
    "objectID": "week-1-vector-io.html#gdal-vector-drivers-read",
    "href": "week-1-vector-io.html#gdal-vector-drivers-read",
    "title": "Vector data I/O",
    "section": "GDAL Vector drivers (read)",
    "text": "GDAL Vector drivers (read)\n\nSince GDAL supports a long list of different geospatial file formats, all are in turn supported by {sf}\nRun the function st_drivers for a full list\n{sf} tries to guess the correct driver based on the file extension (see below)\n\n\n# sf uses the geojson driver, based on the file extension\nstationen_schweiz &lt;- read_sf(\"data/week1-exercises/stationen_schweiz.geojson\")\n\n\n# sf uses the shapefile driver, based on the file extension\nhoheitsgebiet &lt;- read_sf(\"data/week1-exercises/HOHEITSGEBIET_FR.shp\")\n\n\nThe read_sf() function is a wrapper around the st_read() function, which is the actual function that reads the data. I use read_sf since this wrapper’s default value for the quiet argument is TRUE (less verbose)",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Vector data I/O</span>"
    ]
  },
  {
    "objectID": "week-1-vector-io.html#multiple-layers-in-one-file",
    "href": "week-1-vector-io.html#multiple-layers-in-one-file",
    "title": "Vector data I/O",
    "section": "Multiple layers in one file",
    "text": "Multiple layers in one file\n\nSome file formats, e.g. Geopackages (*.gpkg) or Geodatabases (*.gdb) support multiple datasets in a single file.\nIf no specific layer is requested read_sf() will import the first available layer\nIf more than 1 layers are available, read_sf() will return a warning\nThe function st_layers() will list all available layers\n\n\ntlm3d_path &lt;- \"data/week1-exercises/swiss_TLM3D.gpkg\"\n\n# Note the warning\ntlm3d &lt;- read_sf(tlm3d_path)\n\nWarning in CPL_read_ogr(dsn, layer, query, as.character(options), quiet, :\nautomatically selected the first layer in a data source containing more than\none.\n\n\n\n\n# This will list all layers, including some metadata\nst_layers(tlm3d_path)\n\nDriver: GPKG \nAvailable layers:\n  layer_name    geometry_type features fields       crs_name\n1     tlm_bb 3D Multi Polygon    49321     14 CH1903+ / LV95\n2      dummy            Point        3      0 CH1903+ / LV95\n\n\n\ntlm_bb &lt;- read_sf(tlm3d_path, \"tlm_bb\")",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Vector data I/O</span>"
    ]
  },
  {
    "objectID": "week-1-vector-io.html#sql-queries-during-import",
    "href": "week-1-vector-io.html#sql-queries-during-import",
    "title": "Vector data I/O",
    "section": "SQL queries during import",
    "text": "SQL queries during import\n\nread_sf() understands an Spatialite SQL query provided in the query = argument\nIn case query = is used, the layers = argument should be skipped (since the layers is specified in the query)\n\n\ntlm_seen &lt;- read_sf(\n  tlm3d_path, \n  query = \"SELECT objektart, geom FROM tlm_bb WHERE objektart = 'Stehende Gewaesser'\"\n  )",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Vector data I/O</span>"
    ]
  },
  {
    "objectID": "week-1-vector-io.html#gdal-vector-drivers-write",
    "href": "week-1-vector-io.html#gdal-vector-drivers-write",
    "title": "Vector data I/O",
    "section": "GDAL Vector drivers (write)",
    "text": "GDAL Vector drivers (write)\n\nThe function st_write() is used to export an sf object to file\nMost vector drivers support reading and writing (see st_drivers / column write)\nMany file formats support appending to the dataset (see append =)\n\n\nst_write(tlm_seen, \"data-out/seen.geojson\")\n\nWriting layer `seen' to data source `data-out/seen.geojson' using driver `GeoJSON'\nWriting 1189 features with 1 fields and geometry type 3D Multi Polygon.",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Vector data I/O</span>"
    ]
  },
  {
    "objectID": "week-1-spatial-operations.html",
    "href": "week-1-spatial-operations.html",
    "title": "Spatial Vector Operation",
    "section": "",
    "text": "Thematic queries\nlibrary(sf)\n\ntlm3d_path &lt;- \"data/week1-exercises/swiss_TLM3D.gpkg\"\n\ntlm_seen &lt;- read_sf(\n  tlm3d_path, \n  query = \"SELECT objektart, geom FROM tlm_bb WHERE objektart = 'Stehende Gewaesser'\"\n  )\ntlm_bb &lt;- read_sf(tlm3d_path, \"tlm_bb\")\n\n# Subsetting with base-R\ntlm_seen &lt;- tlm_bb[tlm_bb$objektart == \"Stehende Gewaesser\", ]\n\n\nlibrary(dplyr)\n\n\n# Subsetting using dplyr::filter\ntlm_seen &lt;- filter(tlm_bb, objektart == \"Stehende Gewaesser\")",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Spatial Vector Operation</span>"
    ]
  },
  {
    "objectID": "week-1-spatial-operations.html#thematic-queries",
    "href": "week-1-spatial-operations.html#thematic-queries",
    "title": "Spatial Vector Operation",
    "section": "",
    "text": "SQL queries can be performed with file import\n\n\n\nHowever, datasets can also be queried after import using data.frame methods (such as [ or dplyr::filter)",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Spatial Vector Operation</span>"
    ]
  },
  {
    "objectID": "week-1-spatial-operations.html#sec-spatiao-queries",
    "href": "week-1-spatial-operations.html#sec-spatiao-queries",
    "title": "Spatial Vector Operation",
    "section": "Spatial queries using binary predicate functions",
    "text": "Spatial queries using binary predicate functions\nTake the following example:\n\nSelect all forests in the canton of Luzern\n\n\nSpatial query functions include: st_contains(), st_intersects(), st_touches(), st_within(), and many more\nThese spatial queries are called geometric binary predicates\nThis family of functions return so called sparse matrices: a list the same length as x, which, for each element in x, contains the indices of y where the condition is met.\nThey could return cross matrices, but these usually have a larger memory, since they have are \\(x \\times y\\) in size\n\n\n\nluzern &lt;- read_sf(\"data/week1-exercises/luzern.gpkg\")\n\ntlm_wald &lt;- filter(tlm_bb, objektart == \"Wald\")\n\n# The dataset already has this crs (2056), but apparently \n# does not realize this\ntlm_wald &lt;- st_set_crs(tlm_wald, 2056)\n\n\nquery_res &lt;- st_intersects(tlm_wald, luzern)\n\n# Note the length of the output equals nrow(tlm_wald)\nquery_res\n\nSparse geometry binary predicate list of length 8096, where the\npredicate was `intersects'\nfirst 10 elements:\n 1: (empty)\n 2: (empty)\n 3: (empty)\n 4: (empty)\n 5: (empty)\n 6: (empty)\n 7: (empty)\n 8: (empty)\n 9: (empty)\n 10: (empty)\n\n\n\n(The first 10 elements are empty, because to not intersect Luzern)\nThis list can be used to subset x (TRUE where the list is not empty):\n\n\n\n# Note the use of lenghts (with an s) to get the length of each element in the \n# list\nwald_luzern &lt;- tlm_wald[lengths(query_res) &gt; 0,]\n\n\nlibrary(ggplot2)\n\n\nggplot(luzern) + \n  geom_sf(data = wald_luzern, fill = \"darkgreen\") +\n  geom_sf(color = \"red\", fill = NA) \n\n\n\n\n\n\n\nFigure 3.1: Note how some forests are outside the canton’s border. This is the nature of st_intersects. If even a small part of a forest feature is within Luzern, this feature intersects Luzern and is therefore retained. To query only forests that are completly within Luzern, use st_within().",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Spatial Vector Operation</span>"
    ]
  },
  {
    "objectID": "week-1-spatial-operations.html#spatial-queries-using-or-st_filter",
    "href": "week-1-spatial-operations.html#spatial-queries-using-or-st_filter",
    "title": "Spatial Vector Operation",
    "section": "Spatial queries using [ or st_filter",
    "text": "Spatial queries using [ or st_filter\nThe code above was for illustration purposes. The code can be written more concise:\n\n# using sf-methods in base-R\ntlm_wald[luzern,, op = st_intersects]\n\n# using st_filter\nst_filter(tlm_wald, luzern, .predicate = st_intersects)\n\nThe default value for op and .predicate is st_intersects, so these arguments could also have been omitted:\n\n# using sf-methods in base-R\ntlm_wald[luzern,,]\n\n# using st_filter\nst_filter(tlm_wald, luzern)",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Spatial Vector Operation</span>"
    ]
  },
  {
    "objectID": "week-1-spatial-operations.html#overlay-analysis",
    "href": "week-1-spatial-operations.html#overlay-analysis",
    "title": "Spatial Vector Operation",
    "section": "Overlay Analysis",
    "text": "Overlay Analysis\n\nIn the example illustrated in Figure 3.1, we have the choice of subsetting forests that either intersect Luzern ever so slightly (st_intersects), or that lie completely within Luzern (st_within).\nDepending on the question, both options can be unsatisfactory (e.g. if the question was Which percentage of Luzern is covered by forest?)\nFor some cases, it might be necessary to “cut” the forest area at the cantons border\nThis can be achieved with st_intersection (which is different from intersects)\nThere are several other functions that work on pairs of geometries. See Geometric operations on pairs of simple feature geometry sets\nThere are even more functions that work on single geometries, e.g. st_buffer. See Geometric unary operations on simple feature geometry sets\n\n\n\nlibrary(glue)\nlibrary(scales)\nwald_luzern2 &lt;- st_intersection(luzern, wald_luzern)\n\nggplot(luzern) + \n  geom_sf(fill = \"gray\", color = NA) +\n  geom_sf(data = wald_luzern2, fill = \"darkgreen\", color = NA)\n\n\n\n\n\n\n\n\n\nNow, it’s possible to compute the area of Luzern and the forest that intersects Luzern using the function st_area.\nThere are several functions to compute geometric measurements of sf-objects.\n\n\nsum(st_area(wald_luzern2))/st_area(luzern)\n\n0.2721733 [1]",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Spatial Vector Operation</span>"
    ]
  },
  {
    "objectID": "week-1-task.html",
    "href": "week-1-task.html",
    "title": "🚀 Tasks",
    "section": "",
    "text": "Task 1\nDue date for the tasks is the next lesson (week 2).\nOn GitHub:\nOn your local machine:",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>🚀 Tasks</span>"
    ]
  },
  {
    "objectID": "week-1-task.html#task-1",
    "href": "week-1-task.html#task-1",
    "title": "🚀 Tasks",
    "section": "",
    "text": "On GitHub, create a free organisation called ADLS-STDS2025-kuerzel (replace kuerzel with your ZHAW email prefix).\nSubmit the URL to this organisation to us via mail\nIn this Organisation, create a new, blank repository called week-1.\n\n\n\nInstall CLI Software quarto\nCreate a new directory to solve this weeks task.\nMake this folder a git repository (git init) and use the GitHub Repo you created previously as a remote (git remote add origin &lt;URL&gt;)\nCreate a new file called _quarto.yml with the content as shown below\nCreate a new quarto file called index.qmd with the content as shown below\nRun the CLI command quarto preview to preview the document\nRun the CLI command quarto publish gh-pages to publish the document to GitHub Pages\n\n\n\n_quarto.yml\n\nproject:\n  output-dir: _docs\n\n\n\nindex.qmd\n\n# Solution for Week1: Vector data processing\n   \nIn this document, I solve the tasks for week 1 of the course \n*Spatiotemporal Datascience*",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>🚀 Tasks</span>"
    ]
  },
  {
    "objectID": "week-1-task.html#sec-gh-pages",
    "href": "week-1-task.html#sec-gh-pages",
    "title": "🚀 Tasks",
    "section": "Task 2",
    "text": "Task 2\n\nDownload the datasets swissTLM3D and swissboundaries3d from swisstopo.\nAdd the datasets to the local folder you created above, in a subfolder named data\nAdd the data folder to the .gitignore file.\nIn index.qmd, add a code chunk (R or Python) and solve the following tasks using your preferred language.\nUsing swissTLM3d and swissboundaries3d, calculate the percentage of area covered by forest per canton\nVisualize the results (in a map and / or a plot)\nRender the document using quarto preview\nPublish your result using quarto publish gh-pages\n\nA code chunk is added in the following manner. Please consult the Quarto - Getting Started for more information on your local setup.\n\n\nindex.qmd\n\n# Solution for Week1: Vector data processing\n   \nIn this document, I solve the tasks for week 1 of the course \n*Spatiotemporal Datascience*\n\n```{r}\nlibrary(sf)\n\n```",
    "crumbs": [
      "Week 1: Vector Recap",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>🚀 Tasks</span>"
    ]
  },
  {
    "objectID": "week-2.html",
    "href": "week-2.html",
    "title": "Week 2: Geopython Conference",
    "section": "",
    "text": "The concepts of this course are implemented in the programming language R. However, these concepts can be transferred to other programming languages, such as Python and vice versa. For this reason, we will take the opportunity that the 2025 Geopython conference is taking place this week, and some talks are during the course time.\nAn online ticket will be provided to all participants. If you want to attend the conference in person, you will have to pay for the ticket yourself.\nYour assignment (not marked) is to watch at least the talks listed in Table 5.1. We will discuss them the following week. Feel free to watch other topics listed in the conference program.\n\n\n\nTable 5.1: Assigned talks at the Geopython conference\n\n\n\n\n\n\n\n\n\nTime\nTalk\n\n\n\n\n09:15–09:45\nThe earth is not flat! Introducing Spherely and support for spherical geometries in geopandas\n\n\n09:45–10:15\nduckdb-geography: Global vector data in DuckDB\n\n\n11:15–11:45\nScaling Geospatial Techniques to Cloud-Native Platforms",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Week 2: Geopython Conference</span>"
    ]
  },
  {
    "objectID": "week-3-raster-io.html",
    "href": "week-3-raster-io.html",
    "title": "Raster Data I/O",
    "section": "",
    "text": "Import a raster file\nlibrary(terra)\n\ndhm25 &lt;- rast(\"data/week2-exercises/dhm25_lu.tif\")\ndhm25\n\nclass       : SpatRaster \ndimensions  : 2321, 2161, 1  (nrow, ncol, nlyr)\nresolution  : 25, 25  (x, y)\nextent      : 2628987, 2683012, 1179988, 1238013  (xmin, xmax, ymin, ymax)\ncoord. ref. : CH1903+ / LV95 (EPSG:2056) \nsource      : dhm25_lu.tif \nname        : dhm25_lu \nmin value   :    381.1 \nmax value   :   3228.3",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Raster Data I/O</span>"
    ]
  },
  {
    "objectID": "week-3-raster-io.html#import-a-raster-file",
    "href": "week-3-raster-io.html#import-a-raster-file",
    "title": "Raster Data I/O",
    "section": "",
    "text": "terra uses the function rast() to import raster data\nPrinting the object will give you some basic information about the raster\n\nThe number of rows and columns, as well as the number of layers\nThe resolution of the raster, meter per pixel (25 in our case)\nThe extent of the raster, in the coordinate reference system of the raster\nThe coordinate reference system (CRS) of the raster\nThe source (in memory, or a file path)\nThe name(s) of the band(s) (we only have one band in our case)\nThe min and max values of the raster",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Raster Data I/O</span>"
    ]
  },
  {
    "objectID": "week-3-raster-io.html#geotiff",
    "href": "week-3-raster-io.html#geotiff",
    "title": "Raster Data I/O",
    "section": "GeoTIFF",
    "text": "GeoTIFF\n\nGeoTIFF is the most common raster format\nGeoTIFF is an extension to the TIFF format, which includes additional metadata to establish the spatial reference of the file\nThis includes the CRS, the extent, the resolution, and the origin of the raster\nThe metadata is either stored in the header of the file, or in an accompanying file with the same name, but different extension (.tfw or .aux.xml)\nOther important raster file formats include:\n\nCloud optimized GeoTIFF (COG): A GeoTIFF file that is optimized for cloud storage which allows for efficient, partial reading of the file over HTTP\nJPG2000 (.jp2) is a compressed raster format that is often used for satellite imagery\nNetCDF (.nc) is a format that is often used for climate data\nHDF5 (.h5) is a format that is often used for remote sensing data",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Raster Data I/O</span>"
    ]
  },
  {
    "objectID": "week-3-raster-io.html#writing-a-raster-file",
    "href": "week-3-raster-io.html#writing-a-raster-file",
    "title": "Raster Data I/O",
    "section": "Writing a raster file",
    "text": "Writing a raster file\n\nYou can write a raster object to a file using the writeRaster() function\n\n\nwriteRaster(dhm25, \"data-out/dhm25_lu.tif\", overwrite = TRUE)",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Raster Data I/O</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html",
    "href": "week-3-raster-operations.html",
    "title": "Raster Operations",
    "section": "",
    "text": "Introduction",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#introduction",
    "href": "week-3-raster-operations.html#introduction",
    "title": "Raster Operations",
    "section": "",
    "text": "Map algebra can be defined as operations that modify or summarize raster cell values, with reference to surrounding cells, zones, or statistical functions that apply to every cell.\nMap algebra divides raster operations into four subclasses:\n\nLocal or per-cell operations\nFocal or neighborhood operations. Most often the output cell value is the result of a 3 x 3 input cell block\nZonal operations are similar to focal operations, but the surrounding pixel grid on which new values are computed can have irregular sizes and shapes\nGlobal or per-raster operations. That means the output cell derives its value potentially from one or several entire rasters",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#global-operation-1",
    "href": "week-3-raster-operations.html#global-operation-1",
    "title": "Raster Operations",
    "section": "Global Operation (1)",
    "text": "Global Operation (1)\n\nThe most common global operations are descriptive statistics for the entire raster dataset such as the minimum, maximum or mean value.\nFor example: What is the mean elevation value for Luxembourg?\n\n\n\n\n\n\n\n\n\nFigure 7.1: Elevation of Luxembourg\n\n\n\n\n\n\n# note: mean(r) does not work, since \"mean\" is used as a local operator\nmean_elev &lt;- global(r, mean, na.rm = TRUE)\n\nmean_elev\n\n              mean\nelevation 347.6488",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#sec-global-2",
    "href": "week-3-raster-operations.html#sec-global-2",
    "title": "Raster Operations",
    "section": "Global Operation (2)",
    "text": "Global Operation (2)\n\nAnother type of “global” operation is distance\nThis function calculates the distance from each cell to a specific target cell\nFor example, what is the distance from each cell to Luxembourg City, the capital of Luxembourg?\n\n\n\n\n\n\n\n\n\n\n\nr_dist &lt;- distance(r, luxembourg_city)\nr_dist &lt;- mask(r_dist, r)",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#sec-zonal-1",
    "href": "week-3-raster-operations.html#sec-zonal-1",
    "title": "Raster Operations",
    "section": "Zonal",
    "text": "Zonal\n\nZonal operations apply an aggregation function to multiple raster cells\nA second raster with categorical values define the “zones”\n\nWhat is the mean altitude per municipality?\n\nmean_vals &lt;- zonal(r, zones, fun = mean, na.rm = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 7.2: The original Zones (E.g. municipalities of Luxembourg)\n\n\n\n\n\n\n\n\n\n\n\nFigure 7.3: Mean elevation per zone / per municipality\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\n\nThe global operation can be seen as a special case of a zonal operation, where the only “Zone” is the entire dataset",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#local-1",
    "href": "week-3-raster-operations.html#local-1",
    "title": "Raster Operations",
    "section": "Local (1)",
    "text": "Local (1)\n\nLocal operations comprise all cell-by-cell operations in one or several layers.\nFor example, we can classify the elevation into values above and below a certain threshold\n\n\n# first, create a boolean copy of the raster\nr_bool &lt;- as.logical(r)\n\nmean_elev &lt;- as.numeric(mean_elev)\nmean_elev\n\n[1] 347.6488\n\nr_bool[r &gt; mean_elev] &lt;- FALSE\nr_bool[r &lt;= mean_elev] &lt;- TRUE",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#local-2",
    "href": "week-3-raster-operations.html#local-2",
    "title": "Raster Operations",
    "section": "Local (2)",
    "text": "Local (2)\n\nThis type of (re-) classification is a very common operation\nFor more than 2 categories, we can use classify\n\n\ncuts &lt;- global(r, quantile, probs = c(0, .33, .66, 1), na.rm = TRUE)\n\nr_classify &lt;- classify(r, as.numeric(cuts))\n\n# this next line just replaces the default labels with some custom ones\nlevels(r_classify) &lt;- data.frame(ID = 0:2, category = c(\"low\",\"mid\",\"high\"))\n\np + tm_shape(r_classify) +\n    tm_raster(style = \"cat\",legend.show = TRUE, palette = \"viridis\", title = \"Elevation\") +\n    tm_layout(legend.show = TRUE)",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#local-3",
    "href": "week-3-raster-operations.html#local-3",
    "title": "Raster Operations",
    "section": "Local (3)",
    "text": "Local (3)\n\nLocal operations are often used with multiple bands\nFor example, we could calculate the mean intensity values of red, green and blue:\n\n\nl7 &lt;- rast(system.file(\"tif/L7_ETMs.tif\",package = \"stars\"))\n\nnames(l7) &lt;- c(\"B\", \"G\", \"R\", \"NIR\", \"SWIR\", \"MIR\")\n\nl7_rgb &lt;- l7[[c(\"R\",\"G\", \"B\")]]\n\nplot(l7_rgb, nr = 1)\n\n\n\n\n\n\n\n\n\nl7_rgb_mean &lt;- mean(l7_rgb)\n\nplot(l7_rgb_mean)",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#local-4",
    "href": "week-3-raster-operations.html#local-4",
    "title": "Raster Operations",
    "section": "Local (4)",
    "text": "Local (4)\n\nIn a more complex usecase, we could use the R, G and B band to calculate a grayscale value (\\(L^*\\)) using the following formula (from here):\n\n\\[\\begin{aligned}\n\nL^* &= 116 \\times Y ^ {\\frac{1}{3}} - 16\\\\\n\nY &= 0.2126 \\times R^\\gamma+0.7152 \\times G^\\gamma+0.0722 \\times B^\\gamma \\\\\n\n\n\\gamma &= 2.2\n\n\\end{aligned}\\]\n\ng &lt;- 2.2\n\nl7 &lt;- l7/255 # scale values to 0-1 (probabbly not necessary)\n\nY &lt;- 0.2126 * l7[[\"R\"]]^g + 0.7152 * l7[[\"G\"]]^g + 0.0722 * l7[[\"B\"]]^g\n\nL &lt;- 116* Y^(1/3)-16\n\n# Plot the result",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#sec-focal-1",
    "href": "week-3-raster-operations.html#sec-focal-1",
    "title": "Raster Operations",
    "section": "Focal",
    "text": "Focal\n\nWhile local functions operate on one cell focal operations take into account a central (focal) cell and its neighbors.\nThe neighborhood (also named kernel, filter or moving window) under consideration is typically of size 3-by-3 cells (that is the central cell and its eight surrounding neighbors), but can take on any other size or shape as defined by the user.\nA focal operation applies an aggregation function to all cells within the specified neighborhood, uses the corresponding output as the new value for the central cell, and moves on to the next central cell\n\n\n\n\n\n\n\nFigure 7.4: Note how, depending on the size of your moving window, NA’s are produced. Source: Lovelace, Nowosad, and Muenchow (2019)\n\n\n\n\nfocal3by3 &lt;- matrix(rep(1,9), ncol = 3)\n\n\nfocal11by11 &lt;- matrix(rep(1,121), ncol = 11)\n\n\nr_foc3 &lt;- focal(r, focal3by3, fun = mean, fillNA = TRUE)\n\nr_foc11 &lt;- focal(r, focal11by11, fun = mean, fillNA = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 7.5: Original values\n\n\n\n\n\n\n\n\n\n\n\nFigure 7.6: Result of a 3x3 Focal Window\n\n\n\n\n\n\n\n\n\n\n\nFigure 7.7: Result of a 11x11 Focal Window\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\n\nNote how the output raster is smaller as the focal window is larger (edge effect)",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#focal-weights-1",
    "href": "week-3-raster-operations.html#focal-weights-1",
    "title": "Raster Operations",
    "section": "Focal weights (1)",
    "text": "Focal weights (1)\n\nThe focal weights we used above were square and evenly weighted\n\n\nfocal3by3\n\n     [,1] [,2] [,3]\n[1,]    1    1    1\n[2,]    1    1    1\n[3,]    1    1    1\n\n\n\nfocal11by11\n\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11]\n [1,]    1    1    1    1    1    1    1    1    1     1     1\n [2,]    1    1    1    1    1    1    1    1    1     1     1\n [3,]    1    1    1    1    1    1    1    1    1     1     1\n [4,]    1    1    1    1    1    1    1    1    1     1     1\n [5,]    1    1    1    1    1    1    1    1    1     1     1\n [6,]    1    1    1    1    1    1    1    1    1     1     1\n [7,]    1    1    1    1    1    1    1    1    1     1     1\n [8,]    1    1    1    1    1    1    1    1    1     1     1\n [9,]    1    1    1    1    1    1    1    1    1     1     1\n[10,]    1    1    1    1    1    1    1    1    1     1     1\n[11,]    1    1    1    1    1    1    1    1    1     1     1",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#focal-weights-2",
    "href": "week-3-raster-operations.html#focal-weights-2",
    "title": "Raster Operations",
    "section": "Focal weights (2)",
    "text": "Focal weights (2)\n\nHowever, we can also create uneven weights:\n\nFor example, a laplacian filter is commonly used for edge detection.\n\nlaplacian &lt;- matrix(c(0,1,0,1,-4,1,0,1,0), nrow=3) \n\nlaplacian\n\n     [,1] [,2] [,3]\n[1,]    0    1    0\n[2,]    1   -4    1\n[3,]    0    1    0\n\n\nSo are the sobel filters\n\nsobel_x &lt;- matrix(c(-1,-2,-1,0,0,0,1,2,1), nrow=3)\n\nsobel_x\n\n     [,1] [,2] [,3]\n[1,]   -1    0    1\n[2,]   -2    0    2\n[3,]   -1    0    1\n\nsobel_y &lt;- matrix(c(1,0,-1,2,0,-2,1,0,-1), nrow=3)\n\nsobel_y\n\n     [,1] [,2] [,3]\n[1,]    1    2    1\n[2,]    0    0    0\n[3,]   -1   -2   -1\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 7.8: Laplacian Filter\n\n\n\n\n\n\n\n\n\n\n\nFigure 7.9: Sobel (x-direction)\n\n\n\n\n\n\n\n\n\n\n\nFigure 7.10: SObel (y-direction)",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#focal-weights-3",
    "href": "week-3-raster-operations.html#focal-weights-3",
    "title": "Raster Operations",
    "section": "Focal weights (3)",
    "text": "Focal weights (3)\n\nWe can also create specific shapes using weights\nWe don’t need to create these matrices by hand. Rather, we can use the function focalMat to create different shapes automatically\n\n\n# Note \n# - \"d\" is evaluated in the units of \"x\" (in our case: meters)\n# - The sum of all weights equals to 1\n# - Note how the corners receive a value of 0\nfocal_circle3000 &lt;- focalMat(x = r, d = 3000, \"circle\")\n\nfocal_circle3000\n\n           [,1]       [,2]       [,3]       [,4]       [,5]\n[1,] 0.00000000 0.00000000 0.03703704 0.00000000 0.00000000\n[2,] 0.03703704 0.03703704 0.03703704 0.03703704 0.03703704\n[3,] 0.03703704 0.03703704 0.03703704 0.03703704 0.03703704\n[4,] 0.03703704 0.03703704 0.03703704 0.03703704 0.03703704\n[5,] 0.03703704 0.03703704 0.03703704 0.03703704 0.03703704\n[6,] 0.03703704 0.03703704 0.03703704 0.03703704 0.03703704\n[7,] 0.00000000 0.00000000 0.03703704 0.00000000 0.00000000\n\n\n\n\n\n\n\nA visual representation of the matrix / filter above\n\n\n\n\n\nfocal_gauss1000 &lt;- focalMat(x = r, d = 1000, \"Gauss\")\n\nfocal_gauss1000\n\n            [,1]        [,2]        [,3]        [,4]        [,5]\n[1,] 0.000241551 0.001082556 0.001784834 0.001082556 0.000241551\n[2,] 0.002942693 0.013188236 0.021743725 0.013188236 0.002942693\n[3,] 0.013188236 0.059105572 0.097448614 0.059105572 0.013188236\n[4,] 0.021743725 0.097448614 0.160665602 0.097448614 0.021743725\n[5,] 0.013188236 0.059105572 0.097448614 0.059105572 0.013188236\n[6,] 0.002942693 0.013188236 0.021743725 0.013188236 0.002942693\n[7,] 0.000241551 0.001082556 0.001784834 0.001082556 0.000241551\n\n\n\n\n\n\n\nA visual representation of the matrix / filter above",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-operations.html#focal-functions-in-terrain-processing",
    "href": "week-3-raster-operations.html#focal-functions-in-terrain-processing",
    "title": "Raster Operations",
    "section": "Focal functions in terrain processing",
    "text": "Focal functions in terrain processing\n\nFocal functions are used to calculate the slope of a specific location, e.g. using the algorithm by Horn (1981)\nSimilarly, calculating the aspect (azimuth) of a location is a very typical task when dealing with elevation data\nThese algorithms are used so often, that they are implemented in a dedicated function (terrain())\n\nterrain(r, \"slope\") |&gt; plot()\nterrain(r, \"aspect\") |&gt; plot()\n\n\n\n\n\n\n\n\n\nFigure 7.11: Calculating slope using a predefined algorithm\n\n\n\n\n\n\n\n\n\n\n\nFigure 7.12: Calculating aspect\n\n\n\n\n\n\n\n\n\n\nHorn, Berthold KP. 1981. “Hill Shading and the Reflectance Map.” Proceedings of the IEEE 69 (1): 14–47.\n\n\nLovelace, Robin, Jakub Nowosad, and Jannes Muenchow. 2019. Geocomputation with r. Chapman; Hall/CRC.",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-vector-operations.html",
    "href": "week-3-raster-vector-operations.html",
    "title": "Raster-Vector Operations",
    "section": "",
    "text": "Two worlds of spatial data",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Raster-Vector Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-vector-operations.html#two-worlds-of-spatial-data",
    "href": "week-3-raster-vector-operations.html#two-worlds-of-spatial-data",
    "title": "Raster-Vector Operations",
    "section": "",
    "text": "Till now, we have treated vector and raster data separately\nHowever, in many cases, you will need to combine both types of data\nFor example, take the Zonal operation we discussed in the chapter Zonal: Typically, your “zones” will be vector polygons",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Raster-Vector Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-vector-operations.html#zonal-operations-with-vector-data",
    "href": "week-3-raster-vector-operations.html#zonal-operations-with-vector-data",
    "title": "Raster-Vector Operations",
    "section": "Zonal operations with vector data",
    "text": "Zonal operations with vector data\n\nThe zonal function in {terra} can handle vector data: however, it requires sf objects to be converted to terra’s own vector format, called SpatVector. - The function vect() can be used to convert sf objects to SpatVector objects:\n\n\nmean_vals &lt;- zonal(r, vect(zones), fun = mean, na.rm = TRUE)\n\n\nzones$mean &lt;- mean_vals$elevation\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 8.1: The original raster data\n\n\n\n\n\n\n\n\n\n\n\nFigure 8.2: The original zones as vector polygons\n\n\n\n\n\n\n\n\n\n\n\nFigure 8.3: The resulting zones (mean elevation per zone), also as vector data",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Raster-Vector Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-vector-operations.html#extracting-raster-values-at-vector-points",
    "href": "week-3-raster-vector-operations.html#extracting-raster-values-at-vector-points",
    "title": "Raster-Vector Operations",
    "section": "Extracting raster values at vector points",
    "text": "Extracting raster values at vector points\n\nA another common operation is to extract raster values at specific points\nLet’s take the example of the city of Luxembourg (see Global Operation (2))\nThe function extract() can be used to extract raster values at specific points\nextract returns a data.frame with\n\none column per raster band (1 in our case)\none row per point (also 1 in our case):\n\n\n\n\n\n\n\n\n\n\n\n\nlux_elev &lt;- extract(r, luxembourg_city)\nlux_elev\n\n  ID elevation\n1  1  293.9805",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Raster-Vector Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-vector-operations.html#vector-to-raster-conversion",
    "href": "week-3-raster-vector-operations.html#vector-to-raster-conversion",
    "title": "Raster-Vector Operations",
    "section": "Vector to raster conversion",
    "text": "Vector to raster conversion\n\nFunctions that combine raster and vector data usually convert vector to raster internally\nSometimes, we might want to do this conversion explicitly. This can be done using the rasterize() function\nThis function takes three arguments:\n\nx: The vector data (either of class sf or SpatVector)\ny: A raster object that defines the extent, resolution, and CRS of the resulting raster (i.e. a “template”)\nfield: The name of the column in the vector data that should be used to fill the raster cells\n\n\n\n# we can create a template using the input vector. All we have to specify \n# is the resolution of the output raster, which is evalutated in the units of\n# the CRS of the input vector data (meters in our case).\n\ntemplate &lt;- rast(zones, resolution = 1000)\n\nzones_raster &lt;- rasterize(zones, template, \"zone\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) The original zones as polygon data\n\n\n\n\n\n\n\n\n\n\n\n(b) The zones as raster data\n\n\n\n\n\n\n\nFigure 8.4: Note how the conversion to polygons results in a loss of detail\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote that rasters don’t store character information. The above zones are coded as integers with a corresponding look-up table (see ?terra::levels).",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Raster-Vector Operations</span>"
    ]
  },
  {
    "objectID": "week-3-raster-vector-operations.html#raster-to-vector-conversion",
    "href": "week-3-raster-vector-operations.html#raster-to-vector-conversion",
    "title": "Raster-Vector Operations",
    "section": "Raster to vector conversion",
    "text": "Raster to vector conversion\n\nThe opposite operation, converting raster data to vector data, can be done using the {terra} functions as.points, as.lines and as.polygons:\nThe resulting object will be of class SpatVector. This can be converted to the sf class using st_as_sf()\n\n\nzones_poly &lt;- as.polygons(zones_raster) |&gt; \n  st_as_sf()\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) The zones as raster data\n\n\n\n\n\n\n\n\n\n\n\n(b) The zones as polygon data\n\n\n\n\n\n\n\nFigure 8.5: Note how the conversion back to polygons preserves the cell boundaries",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Raster-Vector Operations</span>"
    ]
  },
  {
    "objectID": "week-3-task.html",
    "href": "week-3-task.html",
    "title": "🚀 Tasks",
    "section": "",
    "text": "Content\nToday, we will recap the basics of working with spatial data in R from Geocomputation “Raster Data” (Course GIScience and Geodatabases).\n\n\nTasks\nFollow the instructions in Task 2 from last week to create a new repo in the existing organization. As you did last week, solve the next task in a file named index.qmd.\n\nRedo the task from last week. However, rather than doing it using vector data, convert the data to raster and do the calculations in raster format.\nUsing the R package tictoc, measure the execute time of each step in the process. Do this for the raster approach and for the vector approach from last week.\nCompare the execution times of the two approaches. Which approach is faster? Where is the bottleneck?\nCompare the results of the two approaches. Are they the same? If not, why?",
    "crumbs": [
      "Week 2: Raster Recap",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>🚀 Tasks</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Dorman, Michael. 2023. “Spatial Data\nProgramming with Python — Geobgu.xyz.”\nhttps://geobgu.xyz/py/.\n\n\nHorn, Berthold KP. 1981. “Hill Shading and the Reflectance\nMap.” Proceedings of the IEEE 69 (1): 14–47.\n\n\nLovelace, Robin, Jakub Nowosad, and Jannes Muenchow. 2019.\nGeocomputation with r. Chapman; Hall/CRC.\n\n\nPebesma, Edzer. 2018. “Simple Features for R:\nStandardized Support for Spatial Vector Data.”\nThe R Journal 10 (1): 439–46. https://doi.org/10.32614/RJ-2018-009.",
    "crumbs": [
      "References"
    ]
  }
]