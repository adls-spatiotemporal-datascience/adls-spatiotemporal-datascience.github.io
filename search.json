[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spatiotemporal Datascience",
    "section": "",
    "text": "Welcome\n\n\n\nImage Source\n\n\nThis course is taught in the Bachelor Degree Applied Digital Life Sciences at the Zurich University of Applied Sciences (ZHAW).\nIn this course, we will learn about methods and tools to analyze spatiotemporal data. We expect that you already have had some experience with spatial data and programming. To start the course, we will recap the following topic from the course GISc and Geodatabases: Geocomputation with R with raster and vector data\n\n\n\n\n\nTable¬†1: The course schedule (might be subject to change).\n\n\n\n\n\n\n\n\n\n\nSW\nCW\nDate\n\n\n\n\nVector Deepdive (Nils Ratnaweera)\n\n\nTutorial (in person)\n1\n8\n2026-02-17\n\n\nTask (async), due: 2026-03-02\n2\n9\n2026-02-24\n\n\nRaster Deepdive (Nils Ratnaweera)\n\n\nTutorial (in person)\n3\n10\n2026-03-03\n\n\nTask (async), due: 2026-03-16\n4\n11\n2026-03-10\n\n\nWeb Mapping (Nils Ratnaweera)\n\n\nTutorial (in person)\n5\n12\n2026-03-17\n\n\nInterpolation and Density Estimation (Patrick Laube)\n\n\nTheory (in person)\n6\n13\n2026-03-24\n\n\nTask (async), due: 2026-04-06\n7\n14\n2026-03-31\n\n\nNetwork Analysis (Patrick Laube)\n\n\nTheory (in person)\n8\n15\n2026-04-07\n\n\nTask (async), due: 2026-04-20\n9\n16\n2026-04-14\n\n\nMovement Analysis I (Patrick Laube)\n\n\nTheory (in person)\n10\n17\n2026-04-21\n\n\nTask (async), due: 2026-05-04\n11\n18\n2026-04-28\n\n\nMovement Analysis II (Patrick Laube)\n\n\nTheory (in person)\n12\n19\n2026-05-05\n\n\nTask (async), due: 2026-05-18\n13\n20\n2026-05-12\n\n\nOral Review (Nils Ratnaweera)\n\n\nIn Person\n14\n21\n2026-05-19",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "syllabus.html",
    "href": "syllabus.html",
    "title": "Syllabus",
    "section": "",
    "text": "Syllabus",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Syllabus</span>"
    ]
  },
  {
    "objectID": "syllabus.html#prerequisites",
    "href": "syllabus.html#prerequisites",
    "title": "Syllabus",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nCompletion of the course GISc and Geodatabases or equivalent experience with:\n\nR programming (tidyverse, basic data wrangling)\nVector data handling with sf\nRaster data handling with terra\n\nBasic familiarity with Git and GitHub\nFamiliarity with the command line",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Syllabus</span>"
    ]
  },
  {
    "objectID": "syllabus.html#assessment",
    "href": "syllabus.html#assessment",
    "title": "Syllabus",
    "section": "Assessment",
    "text": "Assessment\nThe assessment of the course is based to 100% via the so called course work, which are your solutions to the tasks provided throughout the course.\n\nWhat to Submit\nYou must submit solutions for all but one task assigned throughout the course ‚Äî you have one ‚Äújoker‚Äù that you may skip. Each submission will be checked for completeness (pass/fail). In addition, 2 tasks per student will be randomly selected for detailed grading using the criteria below.\nThe due dates are listed in Table¬†1.\n\n\nOral Review\nIn the final lesson, you will have the opportunity to present and discuss one of your solutions in a short individual conversation (~5‚Äì10 minutes). This is your chance to walk us through your approach, highlight what you learned, and reflect on your choices. This oral review will be graded pass / fail.\n\n\nGrading Criteria\nThe randomly selected tasks are evaluated on three dimensions:\n\n\n\n\n\n\n\n\nCriterion\nWeight\nDescription\n\n\n\n\nCorrectness\n40%\nCode runs without errors and produces the expected output\n\n\nDocumentation\n30%\nClear explanations of your approach, code is readable and commented where necessary\n\n\nReflection\n30%\nDiscussion of limitations, alternatives considered, or lessons learned\n\n\n\n\n\nUse of AI Tools\nYou may use AI assistants (ChatGPT, GitHub Copilot, Claude, etc.) to support your work. However:\n\nYour submission must reflect your understanding\nThe documentation and reflection sections are where you demonstrate this\n\nAs a general rule, the use of generative AI systems must be declared (based on der Z-RL-Guidelines AI in assessments, 01.04.2023).\n\nUse of generative AI systems in graded assignments Graded assignments are a type of assessment which, unlike examinations, are completed over a longer period of time that generally exceeds four hours. They mostly have an individual character in terms of the solutions provided and are not supervised. The use of generative AI systems for graded assignments reflects a natural and expected approach towards digital tools by students and continuing education participants and is an expression of their digital competence and modern working methods. However, to ensure that their personal contribution can be assessed, and in the interests of academic integrity, the use of generative AI systems must be made as transparent as possible. The share or extent of the contribution made by generative AI systems to the creative output generated by students and continuing education participants in compiling their graded assignments must be recognisable to third parties. In principle, there is therefore an obligation to declare all generative AI systems that influence a graded assignment in terms of its content. The Annex governs the aforementioned declaration obligation in detail. The provisions contained therein are subsidiary 1 in nature.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Syllabus</span>"
    ]
  },
  {
    "objectID": "syllabus.html#sec-gh-pages",
    "href": "syllabus.html#sec-gh-pages",
    "title": "Syllabus",
    "section": "Submission via GitHub Pages",
    "text": "Submission via GitHub Pages\nEach task is submitted as a rendered Quarto document hosted on GitHub Pages.\n\nInitial Setup\nOn GitHub:\n\nCreate a free organisation with a name of your choice and submit the URL to this organisation via email.\nYou need to do this only once, the rest of the steps are done for each task.\nIn this organisation, create a new, blank repository called vector-deepdive\n\nOn your local machine:\n\nInstall the CLI tool Quarto\nCreate a new directory for this week‚Äôs task\nInitialize a Git repository and link it to your GitHub repo:\ngit init\ngit remote add origin &lt;URL&gt;\nCreate _quarto.yml:\n\n\n_quarto.yml\n\nproject:\n  output-dir: _docs\n\nCreate index.qmd:\n\n\nindex.qmd\n\n# Solution for Vector Deepdive\n\nIn this document, I solve the tasks for *vector deepdive* of the course\n*Spatiotemporal Datascience*.\n\nPreview locally: quarto preview\nPublish: quarto publish gh-pages\n\n\n\nSubsequent Weeks\nFor each new task week, create a new repository in your organisation and follow the same workflow.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Syllabus</span>"
    ]
  },
  {
    "objectID": "syllabus.html#footnotes",
    "href": "syllabus.html#footnotes",
    "title": "Syllabus",
    "section": "",
    "text": "The provisions specified in the Annex thus serve as an ‚Äúalternative‚Äù if no others have been specified.‚Ü©Ô∏é",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Syllabus</span>"
    ]
  },
  {
    "objectID": "vector-deepdive-topological-rel.html",
    "href": "vector-deepdive-topological-rel.html",
    "title": "Topological relations",
    "section": "",
    "text": "Named topological relations",
    "crumbs": [
      "Vector Deepdive",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Topological relations</span>"
    ]
  },
  {
    "objectID": "vector-deepdive-topological-rel.html#named-topological-relations",
    "href": "vector-deepdive-topological-rel.html#named-topological-relations",
    "title": "Topological relations",
    "section": "",
    "text": "We briefly touched topological relations in GIScience and Geodatabases\nTopological relations describe the spatial relationships between objects.\nThey are also called binary topological relationships or binary predicates\nThey are logical statements (TRUE/FALSE) about the spatial relationships between two objects\nThe two objects are defined by ordered sets of points (typically forming points, lines and polygons) in two or more dimensions (Egenhofer and Herring 1990).\n\n\nUsage\n\nTopological relations can be used to subset or join spatial data\nFor example:\n\nSubsetting: Return all rivers that flow through the canton of Zurich\nJoining: For every train station, give me the name of the municipality it lies within\n\n\n\n\nNamed topological relations (I)\n\nThe most common topological relations are offered as functions / tools in most GIS software\nIn sf, the following topological functions are available:\n\nst_intersects()\nst_disjoint()\nst_touches()\nst_crosses()\nst_within()\nst_contains()\nst_contains_properly()\nst_overlaps()\nst_equals()\nst_covers()\nst_covered_by()\nst_equals_exact()\nst_is_within_distance()\n\nThese all work slightly differently, and are used in different contexts.\nFor example:\n\nst_covers() returns TRUE if no points of x are outside y, and at least one point of x is inside y.\nst_touches() returns TRUE if the geometries have at least one point in common, but their interiors do not intersect.\n\n\n\n\nNamed topological relations (II)\n\nSome of the relations mentioned above are symmetrical (the order of the geometries does not matter)\nFor example, if st_touches(x, y) is TRUE, then st_touches(y, x) is also TRUE\nOthers are not, meaning that the order of the geometries is important.\nFor example, st_contains(x, y) returns TRUE if x contains y, but st_contains(y, x) returns FALSE\nSome of the relations require additional arguments, such as st_is_within_distance(), which requires a distance argument\nYou can find the full list of topological relations in the sf documentation using ?geos_binary_pred\n\n\n\nSubset Examples\n\nLet‚Äôs take the example of the playgrounds in Zurich and the public transport stops.\nWe can subset the playground data to only include playgrounds that are close (e.g.¬†100m) to public transport stops\n\n\n\n\n\n\n\n\n\nFigure¬†2.1: Note that the playgrounds within 100m of public transport (red dots) are a subset of all the playgrounds\n\n\n\n\n\n\n\nSpatial join Example (I)\n\nIn a spatial join, we want to add information from one dataset to another based on their spatial relationship\nFor example, we can add the name of the nearest public transport stop to each playground.\nFor this, we will use the function st_nearest_feature\nStrictly speaking, this function is not binary predicate, but is very useful for spatial joins\nTo make the example clearer, I will first discard all unnecessary columns from the datasets\n\n\n\nSimple feature collection with 184 features and 2 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 2677632 ymin: 1242927 xmax: 2687639 ymax: 1253914\nProjected CRS: CH1903+ / LV95\n# A tibble: 184 √ó 3\n   name                                                    geom CHSTNAME        \n * &lt;chr&gt;                                            &lt;POINT [m]&gt; &lt;chr&gt;           \n 1 Buchenweg                                  (2685485 1245793) Z√ºrich, Burgwies\n 2 Buchlern Sportanlage                       (2678406 1248303) Z√ºrich, Friedho‚Ä¶\n 3 Mobile Spielanimation PAZMobile Spielanim‚Ä¶ (2682898 1244212) Z√ºrich, Rote Fa‚Ä¶\n 4 Alfred-Altherr-Terrasse                    (2684082 1249963) Z√ºrich, Langens‚Ä¶\n 5 Auf der Egg                                (2682672 1243867) Z√ºrich, Kalchb√º‚Ä¶\n 6 Belvoirpark                                (2682665 1245835) Z√ºrich, Brunaus‚Ä¶\n 7 Josefswiese                                (2681846 1248909) Z√ºrich, Schiffb‚Ä¶\n 8 Gertrudplatz                               (2681431 1247583) Z√ºrich, Locherg‚Ä¶\n 9 Wahlenpark                                 (2683172 1252246) Z√ºrich, Max-Bil‚Ä¶\n10 Rote Fabrik                                (2683004 1244150) Z√ºrich, Rote Fa‚Ä¶\n# ‚Ñπ 174 more rows\n\n\n\n\nSpatial join Example (II)\n\nIn the previous example, playgrounds_join has the same features as playgrounds, but with an additional column (CHSTNAME)\nThe reason for this, is that there is only one nearest station for every playground\nIn some joins, the number of rows in the joined dataset can be different from the original dataset\nFor example, if we want to join via the method within 100m, the result is different (see below).\nThis is because there can be none, or even multiple public transport stops within 100m of a playground\n\n\n## [1] 184\n## [1] 186\n## Simple feature collection with 186 features and 2 fields\n## Geometry type: POINT\n## Dimension:     XY\n## Bounding box:  xmin: 2677632 ymin: 1242927 xmax: 2687639 ymax: 1253914\n## Projected CRS: CH1903+ / LV95\n## # A tibble: 186 √ó 3\n##    name                                                    geom CHSTNAME        \n##  * &lt;chr&gt;                                            &lt;POINT [m]&gt; &lt;chr&gt;           \n##  1 Buchenweg                                  (2685485 1245793) &lt;NA&gt;            \n##  2 Buchlern Sportanlage                       (2678406 1248303) &lt;NA&gt;            \n##  3 Mobile Spielanimation PAZMobile Spielanim‚Ä¶ (2682898 1244212) Z√ºrich, Rote Fa‚Ä¶\n##  4 Alfred-Altherr-Terrasse                    (2684082 1249963) &lt;NA&gt;            \n##  5 Auf der Egg                                (2682672 1243867) Z√ºrich, Kalchb√º‚Ä¶\n##  6 Belvoirpark                                (2682665 1245835) &lt;NA&gt;            \n##  7 Josefswiese                                (2681846 1248909) &lt;NA&gt;            \n##  8 Gertrudplatz                               (2681431 1247583) &lt;NA&gt;            \n##  9 Wahlenpark                                 (2683172 1252246) &lt;NA&gt;            \n## 10 Rote Fabrik                                (2683004 1244150) Z√ºrich, Rote Fa‚Ä¶\n## # ‚Ñπ 176 more rows\n\n\n\nSpatial join order\n\nNote that as is the case with all joins, the order of the datasets matters\nst_join by default is a left join (the first dataset is the left dataset)\nThe resulting dataset will have the geometry of the left dataset\nThis is especially noticeable when joining datasets of different types\n\n\n\n\n\n\n\n\n\n\n\nif you reverse the order, each stadtkreis will be duplicated for every point in the publictransport dataset it intersects\n\n\n## [1] 12\n## [1] 477\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Dataset kreise with 12 features\n\n\n\n\n\n\n\n\n\n\n\n(b) Dataset kreise_join with 477 features\n\n\n\n\n\n\n\nFigure¬†2.2: Note that all the duplicate stadtkreise overlap each other, so when you visualize the data, the issue is not noticeable",
    "crumbs": [
      "Vector Deepdive",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Topological relations</span>"
    ]
  },
  {
    "objectID": "vector-deepdive-topological-rel.html#custom-topological-relations",
    "href": "vector-deepdive-topological-rel.html#custom-topological-relations",
    "title": "Topological relations",
    "section": "Custom topological relations",
    "text": "Custom topological relations\n\nIn case the named topological relations (see Named topological relations (I)) do not covery a specific usecase, we can gain more fine grained control using so called DE-9IM strings.\nDE-9IM stands for Dimensionally Extended nine-Intersection Model and is the formal definition of the topological relations between two geometries\nDE-9IM powers all binary predicate functions like st_intersects etc.\nThe concept is a bit complex, but the idea is that it describes the topological relationship between two geometries in a 3x3 matrix.\nThe reasons the matrix is 3x3 is because it considers the intersection of the (1) interior, (2) boundary, and (3) exterior of the geometries.\nTable¬†2.1 shows how two overlapping polygons are analyzed using DE-9IM\n\n\n\n\n\nTable¬†2.1: Image source: M. W. Taves commons.wikimedia.org\n\n\n\n\n\n\n\n\n\n\nInterior\nBoundary\nExterior\n\n\n\n\nInterior\n\n\n\n\n\nBoundary\n\n\n\n\n\nExterior\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn the example in Table¬†2.1\n\nthe intersection of both interiors results in an area. This is denoted as 2\nthe intersection of interior with boundary results in a line, this is denoted as 1\nthe intersection of boundary with boundary results in two points, this is denoted as 0\n\nOnce all nine intersections have been regarded and encoded, the result is flattened into a string (with nine characters) which describes the topological relationship precisely\nIn the example in Table¬†2.1, a compact representation as string code is 212101212\nThis concept is especially interesting from the opposite perspective: i.e.¬†we describe the DE-9IM string we are looking for (see next chapter)\n\n\nRook‚Äôs case\n\nAs alluded in the last chapter, the DE-9IM string can help us look for specific relations not covered in the named topological relation\nConsider a chessboard like situation with 3x3 fields (see Figure¬†2.3)\nFrom the origin field, you might be interested to know all fields that share a full edge (i.e.¬†how a rook would move)\nThis relation is not covered by the named topological relations, so we need to model it using a DE-9IM string\n\n\n\n\n\n\n\n\n\nFigure¬†2.3: A 3x3 chessboard with a rook in the center field (origin). Which fields can the rook reach, if the constraint is that the destination field need to share an endge with the origin?\n\n\n\n\n\n\n\nModeling the rook‚Äôs case\n\nTo specify our requirement (destination field must share a boundary with the origin) we need to use the 3x3 DE-9IM we discussed in Table¬†2.1\nThe requirement is, that the interiors should not intersect (F) and the intersection of the boundaries should result in a line (1). All other intersections to not matter (*). This is displayed in Table¬†2.2\n\n\n\n\n\nTable¬†2.2: The DE-9IM for the rooks case. This can be flattend into the string F***1****\n\n\n\n\n\n\n\n\n\n\nInterior\nBoundary\nExterior\n\n\n\n\nInterior\nF\n*\n*\n\n\nBoundary\n*\n1\n*\n\n\nExterior\n*\n*\n*\n\n\n\n\n\n\n\n\n\n\n\n\nImplementation using st_relate\n\nWe can now use this string in the function st_realate to select fields where the condition is met\n\n\n\nSparse geometry binary predicate list of length 1, where the predicate\nwas `relate_pattern'\n 1: 2, 4, 5, 7\n\n\nWe could also create our custom st_rook function and use this as we use other named predicates\n\n\n\n\n\n\n\n\nFigure¬†2.4: The chessboard situation with the potential fields for the rook highlighted with a red outline\n\n\n\n\n\n\n\n\n\nEgenhofer, Max, and John Herring. 1990. ‚ÄúA Mathematical Framework for the Definition of Topological Relations.‚Äù Proc. The Fourth International Symposium on Spatial Data Handing, 803‚Äì13.",
    "crumbs": [
      "Vector Deepdive",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Topological relations</span>"
    ]
  },
  {
    "objectID": "vector-deepdive-duckdb.html",
    "href": "vector-deepdive-duckdb.html",
    "title": "DuckDB",
    "section": "",
    "text": "OLAP vs.¬†OLTP",
    "crumbs": [
      "Vector Deepdive",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>DuckDB</span>"
    ]
  },
  {
    "objectID": "vector-deepdive-duckdb.html#olap-vs.-oltp",
    "href": "vector-deepdive-duckdb.html#olap-vs.-oltp",
    "title": "DuckDB",
    "section": "",
    "text": "OLAP:\n\nRead-mostly workloads\nComplex queries\nread large parts of the data\nbulk appends / updates\n\nOLTP:\n\nMany samll writes and updates\nsimple queries\nread only individual rows",
    "crumbs": [
      "Vector Deepdive",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>DuckDB</span>"
    ]
  },
  {
    "objectID": "vector-deepdive-duckdb.html#in-process-vs.-standalone",
    "href": "vector-deepdive-duckdb.html#in-process-vs.-standalone",
    "title": "DuckDB",
    "section": "In process vs.¬†standalone",
    "text": "In process vs.¬†standalone\n\nDuckDB is an in process database management system, it is not an external process to which your application connects.\nIn other words: there is no client sending instructions nor a server to read and process them\nSQLite works the same way, while PostgreSQL, MySQL etc. do not\n\n\n\n\n\nTable¬†3.1: DuckDB fills a niche that no previous software has filled yet\n\n\n\n\n\n\n\n\n\n\nOLTP\nOLAP\n\n\n\n\nIn-Process\n\n\n\n\nStand-Alone",
    "crumbs": [
      "Vector Deepdive",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>DuckDB</span>"
    ]
  },
  {
    "objectID": "vector-deepdive-duckdb.html#sec-duckdb-practice",
    "href": "vector-deepdive-duckdb.html#sec-duckdb-practice",
    "title": "DuckDB",
    "section": "Duckdb in practice",
    "text": "Duckdb in practice\nWe have prepared a duckdb database (available on moodle) with the data containing the forest in switzerland and the canton boundaries. Download this dataset (wald-kantone.duckdb ) from moodle.",
    "crumbs": [
      "Vector Deepdive",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>DuckDB</span>"
    ]
  },
  {
    "objectID": "vector-deepdive-duckdb.html#install-duckdb",
    "href": "vector-deepdive-duckdb.html#install-duckdb",
    "title": "DuckDB",
    "section": "Install duckdb",
    "text": "Install duckdb\n\nInstall the duckdb CLI and duckdb R package\nInstall the dbeaver Community Version\n\n\nConnect\nUsing dbeaver, connect to the duckdb database\nInstall and load the spatial extension running the following query:\nINSTALL spatial;\nLOAD spatial;\nCheck if you can see both tables stored in the database using the command:\nSHOW TABLES;\nExplore the tables using the basic SQL syntax:\nSELECT * FROM wald;\nSELECT * FROM kantone;\nBefore we proceed, create an R-Tree spatial index for both tables using the following syntax:\nCREATE INDEX kantone_idx ON kantone USING RTREE (geom);\nCREATE INDEX wald_idx ON wald USING RTREE (geom);\n\n\nSQL VIEW\nNow, we would like to recreate Task 1 using SQL. To facilitate this, we are going to make extensive use of VIEWs. But what is a VIEW? geeksforgeeks.org explains it like this:\n\nViews in SQL are a type of virtual table that simplifies how users interact with data across one or more tables. Unlike traditional tables, a view in SQL does not store data on disk; instead, it dynamically retrieves data based on a pre-defined query each time it‚Äôs accessed.\n\nIn other words, you store a SQL statement with a specific name. This helps us create very complex queries in a concatenated manner (rather than nesting). We could also simply create materialized tables as intermediate results. But not only does this increase the size of our database with duplicate data, the intermediate results do not update when something in our source changes.\nOur first VIEW will be a subset of the forest dataset, so that the execution time in the iterative phase is shorter:\nTo create a subset of our forest dataset, we limit the results to 1‚Äô000 rows:\nSELECT * FROM wald LIMIT 1000; \nTo store this as a view, all we need to do is prepend CREATE VIEW somename AS to our query:\n1CREATE VIEW wald2 AS\n2SELECT * FROM wald LIMIT 1000;\n\n1\n\nThis creates a VIEW from‚Ä¶\n\n2\n\n‚Ä¶ the preceeding SELECT statement\n\n\nWe can now call the VIEW above with the following query:\nSELECT * FROM wald2; \n\n\nDevelop SQL Code\nThe following SQL statement gets the intersection of forest and kantone (Task 1).\nSELECT \n  name, \n2  st_intersection(w.geom, k.geom),\n1FROM wald2 w, kantone k;\n\n1\n\nw and k are aliases‚Ä¶\n\n2\n\n‚Ä¶ used in the intersection\n\n\nHowever, we can optimize this query with a WHERE clause:\nSELECT \n  name, \n  st_intersection(w.geom, k.geom),\nFROM wald2 w, kantone k\n1WHERE st_intersects(w.geom, k.geom);\n\n1\n\nThis WHERE clause reduces execution time\n\n\nWe are actually interested in the area of the intersection and the total area of the canton. We can get this information like so:\nSELECT \n  name, \n1  st_area(st_intersection(w.geom, k.geom)) as wald_area,\nFROM wald2 w, kantone k\nWHERE st_intersects(w.geom, k.geom);\n\n1\n\nst_area calculates the are of the intersection\n\n\nThe next step is to aggregate the area per canton. Before we do this, let‚Äôs save this query as a VIEW.\n1CREATE VIEW wald_kantone AS\nSELECT \n  name, \n  st_area(st_intersection(w.geom, k.geom)) AS wald_area,\nFROM wald2 w, kantone k\nWHERE st_intersects(w.geom, k.geom);\n\n1\n\nThis creates a VIEW from the proceeding query\n\n\nWe can now query this VIEW as if it was a table:\nSELECT * FROM wald_kantone; \nTo calculate the total aggregated area per canton, we can use the GROUP BY function:\nSELECT \n3  name,\n2  sum(wald_area) as wald_area\nFROM wald_kantone\n1GROUP BY name;\n\n1\n\nIf we use GROUP BY in a SQL query..\n\n2\n\n‚Ä¶ we need to wrap all columns with aggregate function‚Ä¶\n\n3\n\n‚Ä¶ except for the columns that we use for grouping\n\n\nLet‚Äôs create a VIEW of this as well:\nCREATE VIEW wald_kanton_grp AS\nSELECT \n  name, \n  sum(wald_area) as wald_area\nFROM wald_kantone\nGROUP BY name;\nFinally, we have to join wald_kanton_grp with kantone to get the information of the total size per canton.\nSELECT \n3    kantone.name,\n4    wald_area/area as waldanteil,\nFROM wald_kanton_grp \n1LEFT JOIN kantone\n2ON wald_kanton_grp.name=kantone.name;\n\n1\n\nTO do a join, append the JOIN method after the select statement‚Ä¶\n\n2\n\n‚Ä¶ providing the column names on which to Join on\n\n3\n\nIn the resulting table, we only need the canton name‚Ä¶\n\n4\n\n‚Ä¶ and the fraction wald_area over area (total area of canton)\n\n\nThis, we can save in a VIEW as well:\nCREATE VIEW kanton_frac AS\nSELECT \n    kantone.name,                 \n    wald_area/area as waldanteil, \nFROM wald_kanton_grp \nLEFT JOIN kantone \nON wald_kanton_grp.name=kantone.name\n1ORDER BY waldanteil DESC;\n\n1\n\nWe can ORDER BY to show us the highest values first\n\n\nTill now, we only worked with the first 1‚Äô000 features of our forest dataset, so the results are incorrect. Since we worked with VIEW, it very straightforward to run our analysis on the full dataset. We simply need to replace the VIEW wald2 with the full version of the dataset, (omitting the LIMIT clause).\nWe can‚Äôt simply use CREATE VIEW wald2 since wald2 already exists. We therefore need to use CREATE OR REPLACE VIEW:\n\nCREATE OR REPLACE VIEW wald2\nAS\nSELECT * FROM wald;\nNow we can call kanton_frac again, and we will get a query on the full dataset, since all intermediate VIEWs are updated automatically.\nThis method has the downside that now full query takes a while to process (since no intermediate datasets are materialized).\nSELECT * FROM kanton_frac;",
    "crumbs": [
      "Vector Deepdive",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>DuckDB</span>"
    ]
  },
  {
    "objectID": "vector-deepdive-duckdb.html#import-results-into-r",
    "href": "vector-deepdive-duckdb.html#import-results-into-r",
    "title": "DuckDB",
    "section": "Import results into R",
    "text": "Import results into R\nTo import the data into R (e.g.¬†to create a visualization), we can simply connect to the database, load the spatial extension and the import the VIEW using dbReadTable():",
    "crumbs": [
      "Vector Deepdive",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>DuckDB</span>"
    ]
  },
  {
    "objectID": "vector-deepdive-task.html",
    "href": "vector-deepdive-task.html",
    "title": "üöÄ Tasks",
    "section": "",
    "text": "Task 1\nFollow the instructions in Submission via GitHub Pages to create a new repo in the existing organization. Solve the tasks in a file named index.qmd.\nDownload the datasets swissTLM3D and swissboundaries3d from swisstopo. Using swissTLM3d and swissboundaries3d, calculate the percentage of area covered by forest per canton. Visualize the results (in a map and / or a plot).\nRender the document using quarto preview. Publish your result using quarto publish gh-pages",
    "crumbs": [
      "Vector Deepdive",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>üöÄ Tasks</span>"
    ]
  },
  {
    "objectID": "vector-deepdive-task.html#task-3",
    "href": "vector-deepdive-task.html#task-3",
    "title": "üöÄ Tasks",
    "section": "Task 3",
    "text": "Task 3\nWithout consulting external help, try and specify the DE-9IM string for the queen and bishop‚Äôs case as shown in Figure¬†5.1.\nConcentrate on the boundary-boundary intersection. Note:\n\nNo intersection: F\nPoint intersection: 0\nLine intersetion: 1\nAny intersection: *\n\nThe 3x3 ‚Äúchessboard‚Äù is available on moodle.\n\n\n\n\n\n\n\n\n\n\n\n\n(a) King‚Äôs case (all fields)\n\n\n\n\n\n\n\n\n\n\n\n(b) Bishop‚Äôs case (diagonal fields)\n\n\n\n\n\n\n\nFigure¬†5.1: Different cases for chess piece movements. The King can move in all directions, the Bishop only on the diagonals",
    "crumbs": [
      "Vector Deepdive",
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>üöÄ Tasks</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Egenhofer, Max, and John Herring. 1990. ‚ÄúA Mathematical Framework\nfor the Definition of Topological Relations.‚Äù Proc. The\nFourth International Symposium on Spatial Data Handing, 803‚Äì13.",
    "crumbs": [
      "References"
    ]
  }
]